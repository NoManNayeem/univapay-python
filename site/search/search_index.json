{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Univapay-Python SDK Docs","text":"<p>Welcome to the documentation for the (unofficial) Univapay-Python SDK.</p> <p>What you can do with this SDK:</p> <ul> <li>Build frontend widget configs (one-time, subscription, recurring)</li> <li>Call server-side APIs for Charges, Subscriptions, Refunds, Cancels, Tokens</li> <li>Verify &amp; parse webhooks (flexible header formats)</li> <li>Use handy utilities: currency conversion, idempotency keys, metadata sanitization</li> </ul> <p>Get started:</p> <ul> <li>Quickstart: basic installation, config, and a simple charge</li> <li>Using with Python: common flows and patterns</li> <li>Using with Django &amp; DRF: views/serializers and webhook integration</li> <li>Using with FastAPI: routers and dependency wiring</li> <li>API Reference: auto-generated docs from the SDK</li> </ul> <p>Looking for the demo app? See the Flask demo in <code>examples/univapay_flask_demo/</code>.</p>"},{"location":"API/","title":"SDK API","text":""},{"location":"API/#core","title":"Core","text":"Configuration with precedence <p>explicit kwargs &gt; environment (.env) &gt; defaults</p> <p>Server-side calls require BOTH jwt and secret.</p> Source code in <code>univapay\\config.py</code> <pre><code>@dataclass\nclass UnivapayConfig:\n    \"\"\"\n    Configuration with precedence:\n      explicit kwargs &gt; environment (.env) &gt; defaults\n\n    Server-side calls require BOTH jwt and secret.\n    \"\"\"\n\n    # Credentials\n    jwt: Optional[str] = None\n    secret: Optional[str] = None\n\n    # Routing / network\n    store_id: Optional[str] = None\n    base_url: Optional[str] = None\n    timeout: Optional[float] = None\n\n    # Diagnostics\n    debug: Optional[bool] = None\n\n    # Optional retry hints (client may use these; also available via env)\n    # UNIVAPAY_RETRIES, UNIVAPAY_BACKOFF\n    retries: Optional[int] = None\n    backoff_factor: Optional[float] = None\n\n    # Internal: where each field was sourced from (arg/env/default) for debugging\n    _source: Dict[str, str] = field(default_factory=dict, init=False, repr=False)\n\n    def __post_init__(self) -&gt; None:\n        env = os.environ\n\n        # jwt\n        if self.jwt is None or self.jwt == \"\":\n            self.jwt = env.get(\"UNIVAPAY_JWT\", \"\")\n            self._source[\"jwt\"] = \"env\"\n        else:\n            self._source[\"jwt\"] = \"arg\"\n\n        # secret\n        if self.secret is None or self.secret == \"\":\n            self.secret = env.get(\"UNIVAPAY_SECRET\", \"\")\n            self._source[\"secret\"] = \"env\"\n        else:\n            self._source[\"secret\"] = \"arg\"\n\n        # store_id\n        if self.store_id is None or self.store_id == \"\":\n            self.store_id = env.get(\"UNIVAPAY_STORE_ID\") or None\n            self._source[\"store_id\"] = \"env\"\n        else:\n            self._source[\"store_id\"] = \"arg\"\n\n        # base_url\n        if self.base_url is None or self.base_url == \"\":\n            self.base_url = _normalize_base_url(env.get(\"UNIVAPAY_BASE_URL\"))\n            self._source[\"base_url\"] = \"env/default\"\n        else:\n            self.base_url = _normalize_base_url(self.base_url)\n            self._source[\"base_url\"] = \"arg\"\n\n        # timeout\n        if self.timeout is None:\n            self.timeout = _parse_float(env.get(\"UNIVAPAY_TIMEOUT\"), 30.0)\n            self._source[\"timeout\"] = \"env/default\"\n        else:\n            try:\n                self.timeout = float(self.timeout)\n            except Exception:\n                self.timeout = 30.0\n            self._source[\"timeout\"] = \"arg\"\n\n        # debug\n        if self.debug is None:\n            self.debug = _parse_bool(env.get(\"UNIVAPAY_DEBUG\", \"1\"), True)\n            self._source[\"debug\"] = \"env/default\"\n        else:\n            self.debug = bool(self.debug)\n            self._source[\"debug\"] = \"arg\"\n\n        # optional retry hints\n        if self.retries is None:\n            self.retries = _parse_int(env.get(\"UNIVAPAY_RETRIES\"), 0)\n            self._source[\"retries\"] = \"env/default\"\n        else:\n            try:\n                self.retries = int(self.retries)\n            except Exception:\n                self.retries = 0\n            self._source[\"retries\"] = \"arg\"\n\n        if self.backoff_factor is None:\n            self.backoff_factor = _parse_float(env.get(\"UNIVAPAY_BACKOFF\"), 0.5)\n            self._source[\"backoff_factor\"] = \"env/default\"\n        else:\n            try:\n                self.backoff_factor = float(self.backoff_factor)\n            except Exception:\n                self.backoff_factor = 0.5\n            self._source[\"backoff_factor\"] = \"arg\"\n\n        # Initial debug print (sanitized)\n        _dprint(\n            bool(self.debug),\n            \"Loaded config:\",\n            {\n                \"jwt\": _mask(self.jwt, \"jwt\"),\n                \"secret\": _mask(self.secret, \"secret\"),\n                \"store_id\": self.store_id or None,\n                \"base_url\": self.base_url,\n                \"timeout\": self.timeout,\n                \"debug\": self.debug,\n                \"source\": self._source,\n            },\n        )\n\n    # -------- validation &amp; utils --------\n    def validate(self) -&gt; \"UnivapayConfig\":\n        \"\"\"\n        Validate presence of credentials for server-side API calls.\n        (Widget-only use-cases can bypass by not instantiating this config.)\n        \"\"\"\n        if not self.jwt or not self.secret:\n            _dprint(\n                bool(self.debug),\n                \"Validation failed: jwt/secret missing\",\n                {\"jwt\": _mask(self.jwt, \"jwt\"), \"secret\": _mask(self.secret, \"secret\")},\n            )\n            raise UnivapayConfigError(\n                \"UNIVAPAY_JWT and UNIVAPAY_SECRET are required for server-side API calls.\"\n            )\n        _dprint(bool(self.debug), \"Validation OK\")\n        return self\n\n    def require_store_id(self) -&gt; str:\n        \"\"\"Ensure a store_id is present for endpoints that need it.\"\"\"\n        if not self.store_id:\n            raise UnivapayConfigError(\"UNIVAPAY_STORE_ID is required for this operation.\")\n        return self.store_id\n\n    def masked(self) -&gt; dict:\n        \"\"\"Return a sanitized dict for logging/diagnostics.\"\"\"\n        return {\n            \"jwt\": _mask(self.jwt, \"jwt\"),\n            \"secret\": _mask(self.secret, \"secret\"),\n            \"store_id\": self.store_id,\n            \"base_url\": self.base_url,\n            \"timeout\": self.timeout,\n            \"debug\": self.debug,\n            \"retries\": self.retries,\n            \"backoff_factor\": self.backoff_factor,\n        }\n\n    def copy_with(\n        self,\n        *,\n        jwt: Optional[str] = None,\n        secret: Optional[str] = None,\n        store_id: Optional[str] = None,\n        base_url: Optional[str] = None,\n        timeout: Optional[float] = None,\n        debug: Optional[bool] = None,\n        retries: Optional[int] = None,\n        backoff_factor: Optional[float] = None,\n    ) -&gt; \"UnivapayConfig\":\n        \"\"\"Create a modified copy (handy in tests).\"\"\"\n        return replace(\n            self,\n            jwt=self.jwt if jwt is None else jwt,\n            secret=self.secret if secret is None else secret,\n            store_id=self.store_id if store_id is None else store_id,\n            base_url=_normalize_base_url(base_url if base_url is not None else self.base_url),\n            timeout=self.timeout if timeout is None else float(timeout),\n            debug=self.debug if debug is None else bool(debug),\n            retries=self.retries if retries is None else int(retries),\n            backoff_factor=self.backoff_factor if backoff_factor is None else float(backoff_factor),\n        )\n\n    # -------- alt constructors --------\n    @classmethod\n    def from_env(cls) -&gt; \"UnivapayConfig\":\n        \"\"\"Build config strictly from environment (.env considered if loaded).\"\"\"\n        return cls().validate()\n</code></pre> <p>Lightweight sync client for Univapay REST.</p> <ul> <li>Adds Authorization header \"Bearer {secret}.{jwt}\".</li> <li>Supports Idempotency-Key on mutating requests.</li> <li>Optional simple retries/backoff for transient errors (429/5xx).</li> <li>Prints sanitized debug logs (Authorization redacted).</li> </ul> Source code in <code>univapay\\client.py</code> <pre><code>class UnivapayClient:\n    \"\"\"\n    Lightweight sync client for Univapay REST.\n\n    - Adds Authorization header \"Bearer {secret}.{jwt}\".\n    - Supports Idempotency-Key on mutating requests.\n    - Optional simple retries/backoff for transient errors (429/5xx).\n    - Prints sanitized debug logs (Authorization redacted).\n    \"\"\"\n\n    def __init__(\n        self,\n        config: UnivapayConfig,\n        *,\n        retries: int = 0,\n        backoff_factor: float = 0.5,\n    ):\n        self.config = config.validate()\n        self.retries = max(0, int(retries))\n        self.backoff_factor = max(0.0, float(backoff_factor))\n\n        self._client = httpx.Client(\n            base_url=self.config.base_url,\n            timeout=self.config.timeout,\n            headers={\n                \"User-Agent\": f\"univapay-python/{SDK_VERSION}\",\n            },\n        )\n        dprint(\n            \"Client init\",\n            {\n                \"base_url\": self.config.base_url,\n                \"store_id\": self.config.store_id,\n                \"timeout\": self.config.timeout,\n                \"debug\": self.config.debug,\n                \"retries\": self.retries,\n                \"backoff_factor\": self.backoff_factor,\n                \"sdk_version\": SDK_VERSION,\n            },\n        )\n\n    # ------------ context manager support ------------\n    def __enter__(self) -&gt; \"UnivapayClient\":\n        dprint(\"__enter__()\")\n        return self\n\n    def __exit__(self, exc_type, exc, tb) -&gt; None:\n        dprint(\"__exit__() -&gt; close()\")\n        self.close()\n\n    # ------------ internal helpers ------------\n    def _headers(\n        self,\n        *,\n        idempotency_key: Optional[str] = None,\n        extra: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, str]:\n        h: Dict[str, str] = {\n            \"Authorization\": _auth_header(self.config.secret, self.config.jwt),\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n        }\n        if idempotency_key:\n            h[\"Idempotency-Key\"] = idempotency_key\n        if extra:\n            h.update(extra)\n        djson(\"Request headers\", scrub_headers(h))\n        return h\n\n    def _extract_meta(self, r: httpx.Response) -&gt; Dict[str, Any]:\n        meta: Dict[str, Any] = {k: r.headers.get(k) for k in RATE_HEADERS if k in r.headers}\n        req_id = _first_header(r.headers, REQUEST_ID_HEADERS)\n        if req_id:\n            meta[\"request_id\"] = req_id\n        retry_after = r.headers.get(\"Retry-After\")\n        if retry_after:\n            meta[\"retry_after\"] = retry_after\n        return meta\n\n    def _handle(self, r: httpx.Response) -&gt; Dict[str, Any]:\n        meta = self._extract_meta(r)\n        dprint(\"Response\", {\"status\": r.status_code, \"request_id\": meta.get(\"request_id\")})\n        if meta:\n            dprint(\"Rate limits\", {k: v for k, v in meta.items() if k in RATE_HEADERS})\n\n        # Parse body safely\n        if r.status_code == 204 or not r.content:\n            body: Dict[str, Any] = {}\n        else:\n            try:\n                body = r.json()\n                if not isinstance(body, dict):\n                    body = {\"data\": body}\n            except Exception:\n                body = {\"message\": r.text}\n\n        djson(\"Response body\", body)\n\n        if 200 &lt;= r.status_code &lt; 300:\n            body.setdefault(\"_meta\", {})[\"rate_limits\"] = {k: v for k, v in meta.items() if k in RATE_HEADERS}\n            if meta.get(\"request_id\"):\n                body[\"_meta\"][\"request_id\"] = meta[\"request_id\"]\n            if meta.get(\"retry_after\"):\n                body[\"_meta\"][\"retry_after\"] = meta[\"retry_after\"]\n            return body\n\n        # Error path\n        raise UnivapayHTTPError(r.status_code, body, meta.get(\"request_id\"))\n\n    def _path(self, resource: str) -&gt; str:\n        p = f\"/stores/{self.config.store_id}/{resource}\" if self.config.store_id else f\"/{resource}\"\n        dprint(\"Resolved path\", p)\n        return p\n\n    def _sleep_for_retry(self, attempt: int, *, retry_after_header: Optional[str]) -&gt; float:\n        # Use Retry-After if present (seconds). Fallback to exponential backoff.\n        if retry_after_header:\n            try:\n                # Header may be seconds or HTTP-date; we only support seconds here.\n                secs = float(retry_after_header)\n                if secs &gt;= 0:\n                    return secs\n            except Exception:\n                pass\n        return self.backoff_factor * (2 ** attempt)\n\n    def _send_with_retries(self, method: str, url: str, **kwargs) -&gt; httpx.Response:\n        attempt = 0\n        while True:\n            try:\n                dprint(\"HTTP send\", {\"method\": method.upper(), \"url\": url})\n                r = self._client.request(method, url, **kwargs)\n                if r.status_code in TRANSIENT_STATUS and attempt &lt; self.retries:\n                    wait = self._sleep_for_retry(attempt, retry_after_header=r.headers.get(\"Retry-After\"))\n                    dprint(\n                        \"Transient response -&gt; retry\",\n                        {\"status\": r.status_code, \"attempt\": attempt + 1, \"sleep\": wait},\n                    )\n                    time.sleep(max(0.0, wait))\n                    attempt += 1\n                    continue\n                return r\n            except (httpx.ConnectError, httpx.ReadTimeout, httpx.RemoteProtocolError, httpx.HTTPError) as e:\n                if attempt &lt; self.retries:\n                    wait = self.backoff_factor * (2 ** attempt)\n                    dprint(\n                        \"Network error -&gt; retry\",\n                        {\"error\": repr(e), \"attempt\": attempt + 1, \"sleep\": wait},\n                    )\n                    time.sleep(max(0.0, wait))\n                    attempt += 1\n                    continue\n                dprint(\"Network error -&gt; giving up\", {\"error\": repr(e)})\n                raise UnivapayHTTPError(-1, {\"message\": str(e)}, None) from e\n\n    # ------------ public request helpers ------------\n    def get(\n        self,\n        resource_path: str,\n        *,\n        polling: bool = False,\n        params: Dict[str, Any] | None = None,\n        extra_headers: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        params = dict(params or {})\n        if polling:\n            params[\"polling\"] = \"true\"\n        dprint(\"GET\", {\"path\": resource_path, \"params\": params})\n        r = self._send_with_retries(\n            \"GET\",\n            resource_path,\n            params=params,\n            headers=self._headers(extra=extra_headers),\n        )\n        return self._handle(r)\n\n    def post(\n        self,\n        resource_path: str,\n        *,\n        json: Dict[str, Any],\n        idempotency_key: Optional[str] = None,\n        params: Dict[str, Any] | None = None,\n        extra_headers: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        dprint(\"POST\", {\"path\": resource_path})\n        djson(\"Request JSON\", json)\n        r = self._send_with_retries(\n            \"POST\",\n            resource_path,\n            json=json,\n            params=params,\n            headers=self._headers(idempotency_key=idempotency_key, extra=extra_headers),\n        )\n        return self._handle(r)\n\n    def patch(\n        self,\n        resource_path: str,\n        *,\n        json: Dict[str, Any],\n        idempotency_key: Optional[str] = None,\n        params: Dict[str, Any] | None = None,\n        extra_headers: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        dprint(\"PATCH\", {\"path\": resource_path})\n        djson(\"Request JSON\", json)\n        r = self._send_with_retries(\n            \"PATCH\",\n            resource_path,\n            json=json,\n            params=params,\n            headers=self._headers(idempotency_key=idempotency_key, extra=extra_headers),\n        )\n        return self._handle(r)\n\n    def put(\n        self,\n        resource_path: str,\n        *,\n        json: Dict[str, Any],\n        idempotency_key: Optional[str] = None,\n        params: Dict[str, Any] | None = None,\n        extra_headers: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        dprint(\"PUT\", {\"path\": resource_path})\n        djson(\"Request JSON\", json)\n        r = self._send_with_retries(\n            \"PUT\",\n            resource_path,\n            json=json,\n            params=params,\n            headers=self._headers(idempotency_key=idempotency_key, extra=extra_headers),\n        )\n        return self._handle(r)\n\n    def delete(\n        self,\n        resource_path: str,\n        *,\n        json: Optional[Dict[str, Any]] = None,\n        idempotency_key: Optional[str] = None,\n        params: Dict[str, Any] | None = None,\n        extra_headers: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        dprint(\"DELETE\", {\"path\": resource_path})\n        if json is not None:\n            djson(\"Request JSON\", json)\n        r = self._send_with_retries(\n            \"DELETE\",\n            resource_path,\n            json=json,\n            params=params,\n            headers=self._headers(idempotency_key=idempotency_key, extra=extra_headers),\n        )\n        return self._handle(r)\n\n    def head(\n        self,\n        resource_path: str,\n        *,\n        params: Dict[str, Any] | None = None,\n        extra_headers: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        dprint(\"HEAD\", {\"path\": resource_path, \"params\": params or {}})\n        r = self._send_with_retries(\n            \"HEAD\",\n            resource_path,\n            params=params or {},\n            headers=self._headers(extra=extra_headers),\n        )\n        # HEAD returns no body; expose meta only\n        meta = self._extract_meta(r)\n        return {\"_meta\": {\"rate_limits\": {k: v for k, v in meta.items() if k in RATE_HEADERS},\n                          \"request_id\": meta.get(\"request_id\"),\n                          \"retry_after\": meta.get(\"retry_after\")}}\n\n    def close(self) -&gt; None:\n        dprint(\"Client close()\")\n        self._client.close()\n</code></pre>"},{"location":"API/#univapay.config.UnivapayConfig.backoff_factor","title":"<code>backoff_factor = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.base_url","title":"<code>base_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.debug","title":"<code>debug = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.jwt","title":"<code>jwt = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.retries","title":"<code>retries = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.secret","title":"<code>secret = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.store_id","title":"<code>store_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.timeout","title":"<code>timeout = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.__init__","title":"<code>__init__(jwt=None, secret=None, store_id=None, base_url=None, timeout=None, debug=None, retries=None, backoff_factor=None)</code>","text":""},{"location":"API/#univapay.config.UnivapayConfig.__post_init__","title":"<code>__post_init__()</code>","text":"Source code in <code>univapay\\config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    env = os.environ\n\n    # jwt\n    if self.jwt is None or self.jwt == \"\":\n        self.jwt = env.get(\"UNIVAPAY_JWT\", \"\")\n        self._source[\"jwt\"] = \"env\"\n    else:\n        self._source[\"jwt\"] = \"arg\"\n\n    # secret\n    if self.secret is None or self.secret == \"\":\n        self.secret = env.get(\"UNIVAPAY_SECRET\", \"\")\n        self._source[\"secret\"] = \"env\"\n    else:\n        self._source[\"secret\"] = \"arg\"\n\n    # store_id\n    if self.store_id is None or self.store_id == \"\":\n        self.store_id = env.get(\"UNIVAPAY_STORE_ID\") or None\n        self._source[\"store_id\"] = \"env\"\n    else:\n        self._source[\"store_id\"] = \"arg\"\n\n    # base_url\n    if self.base_url is None or self.base_url == \"\":\n        self.base_url = _normalize_base_url(env.get(\"UNIVAPAY_BASE_URL\"))\n        self._source[\"base_url\"] = \"env/default\"\n    else:\n        self.base_url = _normalize_base_url(self.base_url)\n        self._source[\"base_url\"] = \"arg\"\n\n    # timeout\n    if self.timeout is None:\n        self.timeout = _parse_float(env.get(\"UNIVAPAY_TIMEOUT\"), 30.0)\n        self._source[\"timeout\"] = \"env/default\"\n    else:\n        try:\n            self.timeout = float(self.timeout)\n        except Exception:\n            self.timeout = 30.0\n        self._source[\"timeout\"] = \"arg\"\n\n    # debug\n    if self.debug is None:\n        self.debug = _parse_bool(env.get(\"UNIVAPAY_DEBUG\", \"1\"), True)\n        self._source[\"debug\"] = \"env/default\"\n    else:\n        self.debug = bool(self.debug)\n        self._source[\"debug\"] = \"arg\"\n\n    # optional retry hints\n    if self.retries is None:\n        self.retries = _parse_int(env.get(\"UNIVAPAY_RETRIES\"), 0)\n        self._source[\"retries\"] = \"env/default\"\n    else:\n        try:\n            self.retries = int(self.retries)\n        except Exception:\n            self.retries = 0\n        self._source[\"retries\"] = \"arg\"\n\n    if self.backoff_factor is None:\n        self.backoff_factor = _parse_float(env.get(\"UNIVAPAY_BACKOFF\"), 0.5)\n        self._source[\"backoff_factor\"] = \"env/default\"\n    else:\n        try:\n            self.backoff_factor = float(self.backoff_factor)\n        except Exception:\n            self.backoff_factor = 0.5\n        self._source[\"backoff_factor\"] = \"arg\"\n\n    # Initial debug print (sanitized)\n    _dprint(\n        bool(self.debug),\n        \"Loaded config:\",\n        {\n            \"jwt\": _mask(self.jwt, \"jwt\"),\n            \"secret\": _mask(self.secret, \"secret\"),\n            \"store_id\": self.store_id or None,\n            \"base_url\": self.base_url,\n            \"timeout\": self.timeout,\n            \"debug\": self.debug,\n            \"source\": self._source,\n        },\n    )\n</code></pre>"},{"location":"API/#univapay.config.UnivapayConfig.copy_with","title":"<code>copy_with(*, jwt=None, secret=None, store_id=None, base_url=None, timeout=None, debug=None, retries=None, backoff_factor=None)</code>","text":"<p>Create a modified copy (handy in tests).</p> Source code in <code>univapay\\config.py</code> <pre><code>def copy_with(\n    self,\n    *,\n    jwt: Optional[str] = None,\n    secret: Optional[str] = None,\n    store_id: Optional[str] = None,\n    base_url: Optional[str] = None,\n    timeout: Optional[float] = None,\n    debug: Optional[bool] = None,\n    retries: Optional[int] = None,\n    backoff_factor: Optional[float] = None,\n) -&gt; \"UnivapayConfig\":\n    \"\"\"Create a modified copy (handy in tests).\"\"\"\n    return replace(\n        self,\n        jwt=self.jwt if jwt is None else jwt,\n        secret=self.secret if secret is None else secret,\n        store_id=self.store_id if store_id is None else store_id,\n        base_url=_normalize_base_url(base_url if base_url is not None else self.base_url),\n        timeout=self.timeout if timeout is None else float(timeout),\n        debug=self.debug if debug is None else bool(debug),\n        retries=self.retries if retries is None else int(retries),\n        backoff_factor=self.backoff_factor if backoff_factor is None else float(backoff_factor),\n    )\n</code></pre>"},{"location":"API/#univapay.config.UnivapayConfig.from_env","title":"<code>from_env()</code>  <code>classmethod</code>","text":"<p>Build config strictly from environment (.env considered if loaded).</p> Source code in <code>univapay\\config.py</code> <pre><code>@classmethod\ndef from_env(cls) -&gt; \"UnivapayConfig\":\n    \"\"\"Build config strictly from environment (.env considered if loaded).\"\"\"\n    return cls().validate()\n</code></pre>"},{"location":"API/#univapay.config.UnivapayConfig.masked","title":"<code>masked()</code>","text":"<p>Return a sanitized dict for logging/diagnostics.</p> Source code in <code>univapay\\config.py</code> <pre><code>def masked(self) -&gt; dict:\n    \"\"\"Return a sanitized dict for logging/diagnostics.\"\"\"\n    return {\n        \"jwt\": _mask(self.jwt, \"jwt\"),\n        \"secret\": _mask(self.secret, \"secret\"),\n        \"store_id\": self.store_id,\n        \"base_url\": self.base_url,\n        \"timeout\": self.timeout,\n        \"debug\": self.debug,\n        \"retries\": self.retries,\n        \"backoff_factor\": self.backoff_factor,\n    }\n</code></pre>"},{"location":"API/#univapay.config.UnivapayConfig.require_store_id","title":"<code>require_store_id()</code>","text":"<p>Ensure a store_id is present for endpoints that need it.</p> Source code in <code>univapay\\config.py</code> <pre><code>def require_store_id(self) -&gt; str:\n    \"\"\"Ensure a store_id is present for endpoints that need it.\"\"\"\n    if not self.store_id:\n        raise UnivapayConfigError(\"UNIVAPAY_STORE_ID is required for this operation.\")\n    return self.store_id\n</code></pre>"},{"location":"API/#univapay.config.UnivapayConfig.validate","title":"<code>validate()</code>","text":"<p>Validate presence of credentials for server-side API calls. (Widget-only use-cases can bypass by not instantiating this config.)</p> Source code in <code>univapay\\config.py</code> <pre><code>def validate(self) -&gt; \"UnivapayConfig\":\n    \"\"\"\n    Validate presence of credentials for server-side API calls.\n    (Widget-only use-cases can bypass by not instantiating this config.)\n    \"\"\"\n    if not self.jwt or not self.secret:\n        _dprint(\n            bool(self.debug),\n            \"Validation failed: jwt/secret missing\",\n            {\"jwt\": _mask(self.jwt, \"jwt\"), \"secret\": _mask(self.secret, \"secret\")},\n        )\n        raise UnivapayConfigError(\n            \"UNIVAPAY_JWT and UNIVAPAY_SECRET are required for server-side API calls.\"\n        )\n    _dprint(bool(self.debug), \"Validation OK\")\n    return self\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.backoff_factor","title":"<code>backoff_factor = max(0.0, float(backoff_factor))</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.client.UnivapayClient.config","title":"<code>config = config.validate()</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.client.UnivapayClient.retries","title":"<code>retries = max(0, int(retries))</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.client.UnivapayClient.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def __enter__(self) -&gt; \"UnivapayClient\":\n    dprint(\"__enter__()\")\n    return self\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.__exit__","title":"<code>__exit__(exc_type, exc, tb)</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def __exit__(self, exc_type, exc, tb) -&gt; None:\n    dprint(\"__exit__() -&gt; close()\")\n    self.close()\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.__init__","title":"<code>__init__(config, *, retries=0, backoff_factor=0.5)</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def __init__(\n    self,\n    config: UnivapayConfig,\n    *,\n    retries: int = 0,\n    backoff_factor: float = 0.5,\n):\n    self.config = config.validate()\n    self.retries = max(0, int(retries))\n    self.backoff_factor = max(0.0, float(backoff_factor))\n\n    self._client = httpx.Client(\n        base_url=self.config.base_url,\n        timeout=self.config.timeout,\n        headers={\n            \"User-Agent\": f\"univapay-python/{SDK_VERSION}\",\n        },\n    )\n    dprint(\n        \"Client init\",\n        {\n            \"base_url\": self.config.base_url,\n            \"store_id\": self.config.store_id,\n            \"timeout\": self.config.timeout,\n            \"debug\": self.config.debug,\n            \"retries\": self.retries,\n            \"backoff_factor\": self.backoff_factor,\n            \"sdk_version\": SDK_VERSION,\n        },\n    )\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.close","title":"<code>close()</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def close(self) -&gt; None:\n    dprint(\"Client close()\")\n    self._client.close()\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.delete","title":"<code>delete(resource_path, *, json=None, idempotency_key=None, params=None, extra_headers=None)</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def delete(\n    self,\n    resource_path: str,\n    *,\n    json: Optional[Dict[str, Any]] = None,\n    idempotency_key: Optional[str] = None,\n    params: Dict[str, Any] | None = None,\n    extra_headers: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    dprint(\"DELETE\", {\"path\": resource_path})\n    if json is not None:\n        djson(\"Request JSON\", json)\n    r = self._send_with_retries(\n        \"DELETE\",\n        resource_path,\n        json=json,\n        params=params,\n        headers=self._headers(idempotency_key=idempotency_key, extra=extra_headers),\n    )\n    return self._handle(r)\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.get","title":"<code>get(resource_path, *, polling=False, params=None, extra_headers=None)</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def get(\n    self,\n    resource_path: str,\n    *,\n    polling: bool = False,\n    params: Dict[str, Any] | None = None,\n    extra_headers: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    params = dict(params or {})\n    if polling:\n        params[\"polling\"] = \"true\"\n    dprint(\"GET\", {\"path\": resource_path, \"params\": params})\n    r = self._send_with_retries(\n        \"GET\",\n        resource_path,\n        params=params,\n        headers=self._headers(extra=extra_headers),\n    )\n    return self._handle(r)\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.head","title":"<code>head(resource_path, *, params=None, extra_headers=None)</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def head(\n    self,\n    resource_path: str,\n    *,\n    params: Dict[str, Any] | None = None,\n    extra_headers: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    dprint(\"HEAD\", {\"path\": resource_path, \"params\": params or {}})\n    r = self._send_with_retries(\n        \"HEAD\",\n        resource_path,\n        params=params or {},\n        headers=self._headers(extra=extra_headers),\n    )\n    # HEAD returns no body; expose meta only\n    meta = self._extract_meta(r)\n    return {\"_meta\": {\"rate_limits\": {k: v for k, v in meta.items() if k in RATE_HEADERS},\n                      \"request_id\": meta.get(\"request_id\"),\n                      \"retry_after\": meta.get(\"retry_after\")}}\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.patch","title":"<code>patch(resource_path, *, json, idempotency_key=None, params=None, extra_headers=None)</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def patch(\n    self,\n    resource_path: str,\n    *,\n    json: Dict[str, Any],\n    idempotency_key: Optional[str] = None,\n    params: Dict[str, Any] | None = None,\n    extra_headers: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    dprint(\"PATCH\", {\"path\": resource_path})\n    djson(\"Request JSON\", json)\n    r = self._send_with_retries(\n        \"PATCH\",\n        resource_path,\n        json=json,\n        params=params,\n        headers=self._headers(idempotency_key=idempotency_key, extra=extra_headers),\n    )\n    return self._handle(r)\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.post","title":"<code>post(resource_path, *, json, idempotency_key=None, params=None, extra_headers=None)</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def post(\n    self,\n    resource_path: str,\n    *,\n    json: Dict[str, Any],\n    idempotency_key: Optional[str] = None,\n    params: Dict[str, Any] | None = None,\n    extra_headers: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    dprint(\"POST\", {\"path\": resource_path})\n    djson(\"Request JSON\", json)\n    r = self._send_with_retries(\n        \"POST\",\n        resource_path,\n        json=json,\n        params=params,\n        headers=self._headers(idempotency_key=idempotency_key, extra=extra_headers),\n    )\n    return self._handle(r)\n</code></pre>"},{"location":"API/#univapay.client.UnivapayClient.put","title":"<code>put(resource_path, *, json, idempotency_key=None, params=None, extra_headers=None)</code>","text":"Source code in <code>univapay\\client.py</code> <pre><code>def put(\n    self,\n    resource_path: str,\n    *,\n    json: Dict[str, Any],\n    idempotency_key: Optional[str] = None,\n    params: Dict[str, Any] | None = None,\n    extra_headers: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    dprint(\"PUT\", {\"path\": resource_path})\n    djson(\"Request JSON\", json)\n    r = self._send_with_retries(\n        \"PUT\",\n        resource_path,\n        json=json,\n        params=params,\n        headers=self._headers(idempotency_key=idempotency_key, extra=extra_headers),\n    )\n    return self._handle(r)\n</code></pre>"},{"location":"API/#resources","title":"Resources","text":"<p>One-time &amp; recurring charges API.</p> Notes <ul> <li>For one-time: pass a transaction token produced by a one-time widget.</li> <li>For recurring: pass a transaction token produced by a 'recurring' widget.</li> <li>Use <code>idempotency_key</code> on POSTs to avoid duplicate charges on retries.</li> <li>Use <code>get(..., polling=True)</code> or <code>wait_until_terminal(...)</code> to block until a terminal status.</li> </ul> Source code in <code>univapay\\resources\\charges.py</code> <pre><code>class ChargesAPI:\n    \"\"\"\n    One-time &amp; recurring charges API.\n\n    Notes:\n      - For one-time: pass a transaction token produced by a one-time widget.\n      - For recurring: pass a transaction token produced by a 'recurring' widget.\n      - Use `idempotency_key` on POSTs to avoid duplicate charges on retries.\n      - Use `get(..., polling=True)` or `wait_until_terminal(...)` to block until a terminal status.\n    \"\"\"\n\n    def __init__(self, client: UnivapayClient):\n        self.client = client\n        dprint(\"charges.__init__()\", {\"base_path\": _charges_base(self.client)})\n\n    # ----------------------- create: one-time -----------------------\n\n    def create_one_time(\n        self,\n        *,\n        token_id: str,\n        amount: int,\n        currency: str = \"jpy\",\n        capture: bool = True,\n        metadata: Optional[Dict[str, Any]] = None,\n        idempotency_key: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Charge:\n        \"\"\"\n        Create a one-time charge using a one-time transaction token.\n        \"\"\"\n        _validate_token(token_id)\n        _validate_amount(amount)\n        currency = _validate_currency(currency)\n\n        dprint(\"charges.create_one_time()\", {\n            \"token_id\": token_id,\n            \"amount\": amount,\n            \"currency\": currency,\n            \"capture\": capture,\n            \"idempotency_key_present\": bool(idempotency_key),\n        })\n\n        body = ChargeCreate(\n            transaction_token_id=token_id,\n            amount=amount,\n            currency=currency,\n            capture=capture,\n        ).model_dump(by_alias=True)\n\n        if metadata:\n            body[\"metadata\"] = metadata\n        body.update(extra or {})\n\n        djson(\"charges.create_one_time body\", body)\n        resp = self.client.post(_charges_base(self.client), json=body, idempotency_key=idempotency_key)\n        return Charge.model_validate(resp)\n\n    # ----------------------- create: recurring -----------------------\n\n    def create_recurring(\n        self,\n        *,\n        token_id: str,\n        amount: int,\n        currency: str = \"jpy\",\n        capture: bool = True,\n        metadata: Optional[Dict[str, Any]] = None,\n        idempotency_key: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Charge:\n        \"\"\"\n        Create a charge using a **recurring** transaction token.\n        Endpoint is the same as one-time; the server enforces token type.\n        \"\"\"\n        _validate_token(token_id)\n        _validate_amount(amount)\n        currency = _validate_currency(currency)\n\n        dprint(\"charges.create_recurring()\", {\n            \"token_id\": token_id,\n            \"amount\": amount,\n            \"currency\": currency,\n            \"capture\": capture,\n            \"idempotency_key_present\": bool(idempotency_key),\n        })\n\n        # Delegate to the same creation logic to keep behavior identical.\n        return self.create_one_time(\n            token_id=token_id,\n            amount=amount,\n            currency=currency,\n            capture=capture,\n            metadata=metadata,\n            idempotency_key=idempotency_key,\n            **(extra or {}),\n        )\n\n    # ----------------------- read -----------------------\n\n    def get(self, charge_id: str, *, polling: bool = False) -&gt; Charge:\n        \"\"\"\n        Retrieve a charge. If polling=True, server blocks until a terminal state when supported.\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n        dprint(\"charges.get()\", {\"charge_id\": charge_id, \"polling\": polling})\n        resp = self.client.get(f\"{_charges_base(self.client)}/{charge_id}\", polling=polling)\n        return Charge.model_validate(resp)\n\n    # ----------------------- waiter -----------------------\n\n    def wait_until_terminal(\n        self,\n        charge_id: str,\n        *,\n        server_polling: bool = True,\n        timeout_s: int = 90,\n        interval_s: float = 2.0,\n    ) -&gt; Charge:\n        \"\"\"\n        Block until the charge reaches a terminal state.\n\n        If server_polling=True, perform a single GET with polling=true.\n        Otherwise, poll client-side every interval_s until timeout_s is reached.\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n        if timeout_s &lt;= 0 or interval_s &lt;= 0:\n            raise ValueError(\"timeout_s and interval_s must be positive.\")\n\n        dprint(\"charges.wait_until_terminal()\", {\n            \"charge_id\": charge_id,\n            \"server_polling\": server_polling,\n            \"timeout_s\": timeout_s,\n            \"interval_s\": interval_s,\n        })\n\n        if server_polling:\n            ch = self.get(charge_id, polling=True)\n            dprint(\"charges.wait_until_terminal: server-polling returned\", {\"status\": ch.status})\n            return ch\n\n        deadline = time.time() + timeout_s\n        while True:\n            ch = self.get(charge_id)\n            status_norm = (ch.status or \"\").lower()\n            if status_norm in _TERMINAL_STATES:\n                dprint(\"charges.wait_until_terminal -&gt; terminal\", {\"status\": ch.status})\n                return ch\n            if time.time() &gt;= deadline:\n                dprint(\"charges.wait_until_terminal -&gt; timeout\", {\"last_status\": ch.status})\n                return ch\n            time.sleep(interval_s)\n\n    # ----------------------- actions -----------------------\n\n    def refund(\n        self,\n        charge_id: str,\n        *,\n        amount: Optional[int] = None,\n        idempotency_key: Optional[str] = None,\n    ) -&gt; Refund:\n        \"\"\"\n        Create a refund for a charge. If `amount` is None, a full refund may be performed (API-dependent).\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n        if amount is not None:\n            _validate_amount(amount)\n\n        dprint(\"charges.refund()\", {\n            \"charge_id\": charge_id,\n            \"amount\": amount,\n            \"idempotency_key_present\": bool(idempotency_key),\n        })\n\n        path = f\"{_charges_base(self.client)}/{charge_id}/refunds\"\n        body: Dict[str, Any] = {\"amount\": amount} if amount is not None else {}\n        djson(\"charges.refund body\", body)\n        resp = self.client.post(path, json=body, idempotency_key=idempotency_key)\n        return Refund.model_validate(resp)\n\n    def capture(self, charge_id: str, *, idempotency_key: Optional[str] = None, **extra: Any) -&gt; Charge:\n        \"\"\"\n        Capture a previously authorized charge (if your account flow supports auth/capture).\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n        dprint(\"charges.capture()\", {\"charge_id\": charge_id, \"idempotency_key_present\": bool(idempotency_key)})\n        path = f\"{_charges_base(self.client)}/{charge_id}/capture\"\n        djson(\"charges.capture body\", {**extra} if extra else {})\n        resp = self.client.post(path, json={**(extra or {})}, idempotency_key=idempotency_key)\n        return Charge.model_validate(resp)\n\n    def cancel(self, charge_id: str, *, idempotency_key: Optional[str] = None, **extra: Any) -&gt; Charge:\n        \"\"\"\n        Cancel (void) a charge. Route name may vary by capture flow; adjust if needed.\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n        dprint(\"charges.cancel()\", {\"charge_id\": charge_id, \"idempotency_key_present\": bool(idempotency_key)})\n        path = f\"{_charges_base(self.client)}/{charge_id}/cancel\"\n        djson(\"charges.cancel body\", {**extra} if extra else {})\n        resp = self.client.post(path, json={**(extra or {})}, idempotency_key=idempotency_key)\n        return Charge.model_validate(resp)\n</code></pre> <p>Subscriptions API.</p> <ul> <li>Create a subscription from a transaction token produced by a subscription widget.</li> <li>Use <code>idempotency_key</code> on POSTs to avoid dupes on retry.</li> <li>Use <code>get(..., polling=True)</code> or <code>wait_until_terminal(...)</code> to block until a terminal-ish state.</li> <li>Cancel with <code>cancel(subscription_id, ...)</code>.</li> </ul> Source code in <code>univapay\\resources\\subscriptions.py</code> <pre><code>class SubscriptionsAPI:\n    \"\"\"\n    Subscriptions API.\n\n    - Create a subscription from a transaction token produced by a **subscription** widget.\n    - Use `idempotency_key` on POSTs to avoid dupes on retry.\n    - Use `get(..., polling=True)` or `wait_until_terminal(...)` to block until a terminal-ish state.\n    - Cancel with `cancel(subscription_id, ...)`.\n    \"\"\"\n\n    def __init__(self, client: UnivapayClient):\n        self.client = client\n        dprint(\"subscriptions.__init__()\", {\"base_path\": _subs_base(self.client)})\n\n    # ------------------------ create ------------------------\n\n    def create(\n        self,\n        *,\n        token_id: str,\n        amount: int,\n        period: str,\n        currency: str = \"jpy\",\n        metadata: Optional[Dict[str, Any]] = None,\n        start_on: Optional[str] = None,  # ISO date (YYYY-MM-DD)\n        idempotency_key: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Subscription:\n        \"\"\"Create a subscription using a subscription-capable transaction token.\"\"\"\n        _validate_token(token_id)\n        _validate_amount(amount)\n        currency = _validate_currency(currency)\n        period = _validate_period(period)\n\n        dprint(\n            \"subscriptions.create()\",\n            {\n                \"token_id\": token_id,\n                \"amount\": amount,\n                \"period\": period,\n                \"currency\": currency,\n                \"start_on\": start_on,\n                \"idempotency_key_present\": bool(idempotency_key),\n            },\n        )\n\n        body = SubscriptionCreate(\n            transaction_token_id=token_id,\n            amount=amount,\n            currency=currency,\n            period=period,\n            start_on=start_on,\n        ).model_dump(by_alias=True, exclude_none=True)\n\n        if metadata:\n            body[\"metadata\"] = metadata\n        body.update(extra or {})\n\n        djson(\"subscriptions.create body\", body)\n        resp = self.client.post(_subs_base(self.client), json=body, idempotency_key=idempotency_key)\n        return Subscription.model_validate(resp)\n\n    # ------------------------ read ------------------------\n\n    def get(self, subscription_id: str, *, polling: bool = False) -&gt; Subscription:\n        \"\"\"Retrieve a subscription. If polling=True, server may block until steady/terminal state.\"\"\"\n        _validate_id(\"subscription_id\", subscription_id)\n        dprint(\"subscriptions.get()\", {\"subscription_id\": subscription_id, \"polling\": polling})\n        resp = self.client.get(f\"{_subs_base(self.client)}/{subscription_id}\", polling=polling)\n        return Subscription.model_validate(resp)\n\n    # ------------------------ waiter ------------------------\n\n    def wait_until_terminal(\n        self,\n        subscription_id: str,\n        *,\n        server_polling: bool = False,  # default False to avoid long blocks by default\n        timeout_s: int = 60,\n        interval_s: float = 2.0,\n    ) -&gt; Subscription:\n        \"\"\"\n        Return once the subscription is in a terminal-ish state.\n\n        Flow:\n          1) Quick GET without polling; if already terminal-ish (e.g., 'current'), return immediately.\n          2) If server_polling=True, do a single GET with polling=true (server may block).\n          3) Else, client-side poll until terminal or timeout.\n        \"\"\"\n        _validate_id(\"subscription_id\", subscription_id)\n        if timeout_s &lt;= 0 or interval_s &lt;= 0:\n            raise ValueError(\"timeout_s and interval_s must be positive.\")\n\n        dprint(\n            \"subscriptions.wait_until_terminal()\",\n            {\n                \"subscription_id\": subscription_id,\n                \"server_polling\": server_polling,\n                \"timeout_s\": timeout_s,\n                \"interval_s\": interval_s,\n            },\n        )\n\n        # Step 1: quick check\n        sub = self.get(subscription_id, polling=False)\n        if _is_terminal(sub.status):\n            dprint(\"subscriptions.wait_until_terminal: already terminal-ish\", {\"status\": sub.status})\n            return sub\n\n        # Step 2: server polling if requested\n        if server_polling:\n            sub_p = self.get(subscription_id, polling=True)\n            dprint(\"subscriptions.wait_until_terminal: server-polling returned\", {\"status\": sub_p.status})\n            return sub_p\n\n        # Step 3: client-side loop\n        deadline = time.time() + timeout_s\n        last = sub\n        while time.time() &lt; deadline:\n            time.sleep(interval_s)\n            last = self.get(subscription_id, polling=False)\n            if _is_terminal(last.status):\n                dprint(\"subscriptions.wait_until_terminal: reached terminal-ish\", {\"status\": last.status})\n                return last\n\n        dprint(\n            \"subscriptions.wait_until_terminal timeout\",\n            {\"subscription_id\": subscription_id, \"last_status\": getattr(last, \"status\", None)},\n        )\n        return last\n\n    # ------------------------ actions ------------------------\n\n    def cancel(\n        self,\n        subscription_id: str,\n        *,\n        idempotency_key: Optional[str] = None,\n        termination_mode: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Subscription:\n        \"\"\"\n        Cancel a subscription and return the updated Subscription resource.\n\n        Primary attempt: POST /subscriptions/{id}/cancel.\n        Fallback: PATCH /subscriptions/{id} with {'termination_mode': 'immediate'|'on_next_payment'}\n        \"\"\"\n        _validate_id(\"subscription_id\", subscription_id)\n        dprint(\n            \"subscriptions.cancel()\",\n            {\"subscription_id\": subscription_id, \"idempotency_key_present\": bool(idempotency_key)},\n        )\n        base = _subs_base(self.client)\n        path = f\"{base}/{subscription_id}/cancel\"\n        body = {**(extra or {})}\n        if termination_mode:\n            body.setdefault(\"termination_mode\", termination_mode)\n        djson(\"subscriptions.cancel body\", body if body else {})\n        try:\n            resp = self.client.post(path, json=body, idempotency_key=idempotency_key)\n            return Subscription.model_validate(resp)\n        except Exception as e:\n            # Fallback for accounts without /cancel endpoint\n            try:\n                from ..errors import UnivapayHTTPError  # local import to avoid cycle\n                not_found = isinstance(e, UnivapayHTTPError) and e.status in (404, 405)\n            except Exception:\n                not_found = False\n            if not_found:\n                dprint(\"subscriptions.cancel fallback -&gt; PATCH\", {\"subscription_id\": subscription_id})\n                patch_body: Dict[str, Any] = {**(extra or {})}\n                patch_body.setdefault(\"termination_mode\", termination_mode or \"immediate\")\n                djson(\"subscriptions.cancel PATCH body\", patch_body)\n                resp2 = self.client.patch(f\"{base}/{subscription_id}\", json=patch_body, idempotency_key=idempotency_key)\n                return Subscription.model_validate(resp2)\n            raise\n</code></pre> <p>Refunds API (per-charge).</p> Common flows <ul> <li>Create a refund for a given charge (full refund if <code>amount</code> omitted and your account allows it).</li> <li>Get a specific refund (optionally with server-side polling).</li> <li>List refunds for a charge (basic pagination passthrough).</li> <li>Wait until a refund reaches a terminal status.</li> </ul> Source code in <code>univapay\\resources\\refunds.py</code> <pre><code>class RefundsAPI:\n    \"\"\"\n    Refunds API (per-charge).\n\n    Common flows:\n      - Create a refund for a given charge (full refund if `amount` omitted and your account allows it).\n      - Get a specific refund (optionally with server-side polling).\n      - List refunds for a charge (basic pagination passthrough).\n      - Wait until a refund reaches a terminal status.\n    \"\"\"\n\n    def __init__(self, client: UnivapayClient):\n        self.client = client\n\n    # ---- Create ----\n    def create(\n        self,\n        charge_id: str,\n        *,\n        amount: Optional[int] = None,\n        reason: Optional[str] = None,\n        idempotency_key: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Refund:\n        \"\"\"\n        Create a refund.\n\n        Parameters\n        ----------\n        charge_id : str\n            The charge to refund.\n        amount : Optional[int]\n            Amount in minor units. If None, a full refund may be performed (API/account dependent).\n        reason : Optional[str]\n            Optional reason string for audit trails.\n        idempotency_key : Optional[str]\n            Recommended: pass a stable id for safe retries.\n\n        Returns\n        -------\n        Refund\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n        if amount is not None:\n            _validate_amount(amount)\n\n        payload: Dict[str, Any] = {}\n        if amount is not None:\n            payload[\"amount\"] = amount\n        if reason:\n            payload[\"reason\"] = reason\n        payload.update(extra)\n\n        dprint(\n            \"refunds.create()\",\n            {\n                \"charge_id\": charge_id,\n                \"amount\": amount,\n                \"reason\": reason,\n                \"idempotency_key_present\": bool(idempotency_key),\n            },\n        )\n        djson(\"refunds.create body\", payload)\n\n        resp = self.client.post(_base(self.client, charge_id), json=payload, idempotency_key=idempotency_key)\n        return Refund.model_validate(resp)\n\n    def create_full_refund(\n        self,\n        charge_id: str,\n        *,\n        reason: Optional[str] = None,\n        idempotency_key: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Refund:\n        \"\"\"\n        Convenience: request a full refund (omit `amount`).\n        \"\"\"\n        dprint(\"refunds.create_full_refund()\", {\"charge_id\": charge_id})\n        return self.create(\n            charge_id,\n            amount=None,\n            reason=reason,\n            idempotency_key=idempotency_key,\n            **extra,\n        )\n\n    def create_partial_refund(\n        self,\n        charge_id: str,\n        *,\n        amount: int,\n        reason: Optional[str] = None,\n        idempotency_key: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Refund:\n        \"\"\"\n        Convenience: request a partial refund (requires `amount`).\n        \"\"\"\n        dprint(\"refunds.create_partial_refund()\", {\"charge_id\": charge_id, \"amount\": amount})\n        _validate_amount(amount)\n        return self.create(\n            charge_id,\n            amount=amount,\n            reason=reason,\n            idempotency_key=idempotency_key,\n            **extra,\n        )\n\n    # ---- Read ----\n    def get(self, charge_id: str, refund_id: str, *, polling: bool = False) -&gt; Refund:\n        \"\"\"\n        Fetch a specific refund. If `polling=True`, server may block until a terminal state (when supported).\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n        _validate_id(\"refund_id\", refund_id)\n\n        path = f\"{_base(self.client, charge_id)}/{refund_id}\"\n        dprint(\"refunds.get()\", {\"charge_id\": charge_id, \"refund_id\": refund_id, \"polling\": polling})\n        resp = self.client.get(path, polling=polling)\n        return Refund.model_validate(resp)\n\n    # ---- List ----\n    def list(\n        self,\n        charge_id: str,\n        *,\n        limit: Optional[int] = None,\n        cursor: Optional[str] = None,\n        extra_params: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        List refunds for a charge (passthrough dict to preserve API fields/pagination).\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n\n        params: Dict[str, Any] = {}\n        if limit is not None:\n            if not isinstance(limit, int) or limit &lt;= 0:\n                raise ValueError(\"limit must be a positive integer.\")\n            params[\"limit\"] = limit\n        if cursor:\n            params[\"cursor\"] = cursor\n        if extra_params:\n            params.update(extra_params)\n\n        dprint(\"refunds.list()\", {\"charge_id\": charge_id, \"params\": params})\n        resp = self.client.get(_base(self.client, charge_id), params=params)\n        djson(\"refunds.list response\", resp)\n        return resp\n\n    # ---- Wait until terminal ----\n    def wait_until_terminal(\n        self,\n        charge_id: str,\n        refund_id: str,\n        *,\n        server_polling: bool = True,\n        timeout_s: int = 60,\n        interval_s: float = 2.0,\n    ) -&gt; Refund:\n        \"\"\"\n        Block until the refund reaches a terminal-ish status.\n\n        If server_polling=True, perform a single GET with polling=true.\n        Otherwise, poll client-side every `interval_s` until `timeout_s` is reached.\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n        _validate_id(\"refund_id\", refund_id)\n        if timeout_s &lt;= 0 or interval_s &lt;= 0:\n            raise ValueError(\"timeout_s and interval_s must be positive.\")\n\n        dprint(\n            \"refunds.wait_until_terminal()\",\n            {\n                \"charge_id\": charge_id,\n                \"refund_id\": refund_id,\n                \"server_polling\": server_polling,\n                \"timeout_s\": timeout_s,\n                \"interval_s\": interval_s,\n            },\n        )\n\n        if server_polling:\n            # Single blocking call if the API supports server-side polling\n            return self.get(charge_id, refund_id, polling=True)\n\n        # Client-side polling loop\n        deadline = time.time() + timeout_s\n        last = self.get(charge_id, refund_id, polling=False)\n        if _is_terminal(last.status):\n            dprint(\"refunds.wait_until_terminal: already terminal-ish\", {\"status\": last.status})\n            return last\n\n        while time.time() &lt; deadline:\n            time.sleep(interval_s)\n            last = self.get(charge_id, refund_id, polling=False)\n            if _is_terminal(last.status):\n                dprint(\"refunds.wait_until_terminal -&gt; terminal-ish\", {\"status\": last.status})\n                return last\n\n        dprint(\"refunds.wait_until_terminal -&gt; timeout\", {\"last_status\": getattr(last, \"status\", None)})\n        return last\n</code></pre> <p>Cancel helpers for charges (authorization/charge cancel).</p> Most accounts use <p>POST /charges/{charge_id}/cancel</p> <p>Depending on your capture flow, this may be equivalent to voiding an authorization. This SDK provides a <code>void_authorization</code> alias for clarity.</p> Source code in <code>univapay\\resources\\cancels.py</code> <pre><code>class CancelsAPI:\n    \"\"\"\n    Cancel helpers for charges (authorization/charge cancel).\n\n    Most accounts use:\n        POST /charges/{charge_id}/cancel\n\n    Depending on your capture flow, this may be equivalent to voiding an\n    authorization. This SDK provides a `void_authorization` alias for clarity.\n    \"\"\"\n\n    def __init__(self, client: UnivapayClient):\n        self.client = client\n\n    def cancel_charge(\n        self,\n        charge_id: str,\n        *,\n        idempotency_key: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Charge:\n        \"\"\"\n        Cancel a charge (or an authorization prior to capture).\n\n        Parameters\n        ----------\n        charge_id : str\n            The charge identifier to cancel.\n        idempotency_key : Optional[str]\n            Recommended for safe retries.\n        **extra :\n            Additional fields supported by your Univapay account.\n\n        Returns\n        -------\n        Charge\n            The canceled/voided charge resource (typed).\n        \"\"\"\n        _validate_id(\"charge_id\", charge_id)\n\n        path = f\"{self.client._path('charges')}/{charge_id}/cancel\"\n        dprint(\n            \"cancels.cancel_charge()\",\n            {\"charge_id\": charge_id, \"idempotency_key_present\": bool(idempotency_key)},\n        )\n        body = {**extra} if extra else {}\n        djson(\"cancels.cancel_charge body\", body)\n\n        resp = self.client.post(path, json=body, idempotency_key=idempotency_key)\n        return Charge.model_validate(resp)\n\n    # ---------------------------------------------------------------------\n    # Alias for accounts that conceptually distinguish \"void\" vs \"cancel\".\n    # This calls the same endpoint as `cancel_charge` by default.\n    # ---------------------------------------------------------------------\n    def void_authorization(\n        self,\n        charge_id: str,\n        *,\n        idempotency_key: Optional[str] = None,\n        **extra: Any,\n    ) -&gt; Charge:\n        \"\"\"\n        Void a previously authorized (not yet captured) charge.\n\n        Notes\n        -----\n        Many Univapay setups map this to the same route as cancel:\n            POST /charges/{charge_id}/cancel\n\n        Returns\n        -------\n        Charge\n        \"\"\"\n        dprint(\"cancels.void_authorization() -&gt; cancel_charge()\", {\"charge_id\": charge_id})\n        return self.cancel_charge(\n            charge_id,\n            idempotency_key=idempotency_key,\n            **extra,\n        )\n</code></pre> <p>Transaction Tokens API (read-only on the server).</p> <p>Notes: - Transaction tokens are typically created client-side by the Univapay widget. - Use this API to fetch token details server-side when needed (e.g., auditing).</p> Source code in <code>univapay\\resources\\tokens.py</code> <pre><code>class TokensAPI:\n    \"\"\"\n    Transaction Tokens API (read-only on the server).\n\n    Notes:\n    - Transaction tokens are typically created client-side by the Univapay widget.\n    - Use this API to fetch token details server-side when needed (e.g., auditing).\n    \"\"\"\n\n    def __init__(self, client: UnivapayClient):\n        self.client = client\n        dprint(\"tokens.__init__()\", {\"base_path\": _tokens_base(self.client)})\n\n    def get(self, token_id: str) -&gt; TransactionToken:\n        \"\"\"\n        Fetch a transaction token by ID.\n\n        Parameters\n        ----------\n        token_id : str\n            The transaction token id (from the FE widget callback).\n\n        Returns\n        -------\n        TransactionToken\n            A typed model of the token response (extra fields are preserved).\n\n        Raises\n        ------\n        ValueError\n            If token_id is empty/invalid.\n        UnivapayHTTPError\n            If the HTTP call fails.\n        \"\"\"\n        _validate_id(\"token_id\", token_id)\n        dprint(\"tokens.get()\", {\"token_id\": token_id})\n        resp = self.client.get(f\"{_tokens_base(self.client)}/{token_id}\")\n        djson(\"tokens.get response\", resp)\n        return TransactionToken.model_validate(resp)\n\n    def try_get(self, token_id: str) -&gt; Optional[TransactionToken]:\n        \"\"\"\n        Like `get()` but returns None if the token does not exist (HTTP 404).\n        Propagates other HTTP errors.\n        \"\"\"\n        _validate_id(\"token_id\", token_id)\n        dprint(\"tokens.try_get()\", {\"token_id\": token_id})\n        try:\n            return self.get(token_id)\n        except UnivapayHTTPError as e:\n            if e.status == 404:\n                dprint(\"tokens.try_get: not found\", {\"token_id\": token_id})\n                return None\n            dprint(\"tokens.try_get: error\", {\"status\": e.status})\n            raise\n</code></pre>"},{"location":"API/#univapay.resources.ChargesAPI.client","title":"<code>client = client</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.ChargesAPI.__init__","title":"<code>__init__(client)</code>","text":"Source code in <code>univapay\\resources\\charges.py</code> <pre><code>def __init__(self, client: UnivapayClient):\n    self.client = client\n    dprint(\"charges.__init__()\", {\"base_path\": _charges_base(self.client)})\n</code></pre>"},{"location":"API/#univapay.resources.ChargesAPI.cancel","title":"<code>cancel(charge_id, *, idempotency_key=None, **extra)</code>","text":"<p>Cancel (void) a charge. Route name may vary by capture flow; adjust if needed.</p> Source code in <code>univapay\\resources\\charges.py</code> <pre><code>def cancel(self, charge_id: str, *, idempotency_key: Optional[str] = None, **extra: Any) -&gt; Charge:\n    \"\"\"\n    Cancel (void) a charge. Route name may vary by capture flow; adjust if needed.\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n    dprint(\"charges.cancel()\", {\"charge_id\": charge_id, \"idempotency_key_present\": bool(idempotency_key)})\n    path = f\"{_charges_base(self.client)}/{charge_id}/cancel\"\n    djson(\"charges.cancel body\", {**extra} if extra else {})\n    resp = self.client.post(path, json={**(extra or {})}, idempotency_key=idempotency_key)\n    return Charge.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.ChargesAPI.capture","title":"<code>capture(charge_id, *, idempotency_key=None, **extra)</code>","text":"<p>Capture a previously authorized charge (if your account flow supports auth/capture).</p> Source code in <code>univapay\\resources\\charges.py</code> <pre><code>def capture(self, charge_id: str, *, idempotency_key: Optional[str] = None, **extra: Any) -&gt; Charge:\n    \"\"\"\n    Capture a previously authorized charge (if your account flow supports auth/capture).\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n    dprint(\"charges.capture()\", {\"charge_id\": charge_id, \"idempotency_key_present\": bool(idempotency_key)})\n    path = f\"{_charges_base(self.client)}/{charge_id}/capture\"\n    djson(\"charges.capture body\", {**extra} if extra else {})\n    resp = self.client.post(path, json={**(extra or {})}, idempotency_key=idempotency_key)\n    return Charge.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.ChargesAPI.create_one_time","title":"<code>create_one_time(*, token_id, amount, currency='jpy', capture=True, metadata=None, idempotency_key=None, **extra)</code>","text":"<p>Create a one-time charge using a one-time transaction token.</p> Source code in <code>univapay\\resources\\charges.py</code> <pre><code>def create_one_time(\n    self,\n    *,\n    token_id: str,\n    amount: int,\n    currency: str = \"jpy\",\n    capture: bool = True,\n    metadata: Optional[Dict[str, Any]] = None,\n    idempotency_key: Optional[str] = None,\n    **extra: Any,\n) -&gt; Charge:\n    \"\"\"\n    Create a one-time charge using a one-time transaction token.\n    \"\"\"\n    _validate_token(token_id)\n    _validate_amount(amount)\n    currency = _validate_currency(currency)\n\n    dprint(\"charges.create_one_time()\", {\n        \"token_id\": token_id,\n        \"amount\": amount,\n        \"currency\": currency,\n        \"capture\": capture,\n        \"idempotency_key_present\": bool(idempotency_key),\n    })\n\n    body = ChargeCreate(\n        transaction_token_id=token_id,\n        amount=amount,\n        currency=currency,\n        capture=capture,\n    ).model_dump(by_alias=True)\n\n    if metadata:\n        body[\"metadata\"] = metadata\n    body.update(extra or {})\n\n    djson(\"charges.create_one_time body\", body)\n    resp = self.client.post(_charges_base(self.client), json=body, idempotency_key=idempotency_key)\n    return Charge.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.ChargesAPI.create_recurring","title":"<code>create_recurring(*, token_id, amount, currency='jpy', capture=True, metadata=None, idempotency_key=None, **extra)</code>","text":"<p>Create a charge using a recurring transaction token. Endpoint is the same as one-time; the server enforces token type.</p> Source code in <code>univapay\\resources\\charges.py</code> <pre><code>def create_recurring(\n    self,\n    *,\n    token_id: str,\n    amount: int,\n    currency: str = \"jpy\",\n    capture: bool = True,\n    metadata: Optional[Dict[str, Any]] = None,\n    idempotency_key: Optional[str] = None,\n    **extra: Any,\n) -&gt; Charge:\n    \"\"\"\n    Create a charge using a **recurring** transaction token.\n    Endpoint is the same as one-time; the server enforces token type.\n    \"\"\"\n    _validate_token(token_id)\n    _validate_amount(amount)\n    currency = _validate_currency(currency)\n\n    dprint(\"charges.create_recurring()\", {\n        \"token_id\": token_id,\n        \"amount\": amount,\n        \"currency\": currency,\n        \"capture\": capture,\n        \"idempotency_key_present\": bool(idempotency_key),\n    })\n\n    # Delegate to the same creation logic to keep behavior identical.\n    return self.create_one_time(\n        token_id=token_id,\n        amount=amount,\n        currency=currency,\n        capture=capture,\n        metadata=metadata,\n        idempotency_key=idempotency_key,\n        **(extra or {}),\n    )\n</code></pre>"},{"location":"API/#univapay.resources.ChargesAPI.get","title":"<code>get(charge_id, *, polling=False)</code>","text":"<p>Retrieve a charge. If polling=True, server blocks until a terminal state when supported.</p> Source code in <code>univapay\\resources\\charges.py</code> <pre><code>def get(self, charge_id: str, *, polling: bool = False) -&gt; Charge:\n    \"\"\"\n    Retrieve a charge. If polling=True, server blocks until a terminal state when supported.\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n    dprint(\"charges.get()\", {\"charge_id\": charge_id, \"polling\": polling})\n    resp = self.client.get(f\"{_charges_base(self.client)}/{charge_id}\", polling=polling)\n    return Charge.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.ChargesAPI.refund","title":"<code>refund(charge_id, *, amount=None, idempotency_key=None)</code>","text":"<p>Create a refund for a charge. If <code>amount</code> is None, a full refund may be performed (API-dependent).</p> Source code in <code>univapay\\resources\\charges.py</code> <pre><code>def refund(\n    self,\n    charge_id: str,\n    *,\n    amount: Optional[int] = None,\n    idempotency_key: Optional[str] = None,\n) -&gt; Refund:\n    \"\"\"\n    Create a refund for a charge. If `amount` is None, a full refund may be performed (API-dependent).\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n    if amount is not None:\n        _validate_amount(amount)\n\n    dprint(\"charges.refund()\", {\n        \"charge_id\": charge_id,\n        \"amount\": amount,\n        \"idempotency_key_present\": bool(idempotency_key),\n    })\n\n    path = f\"{_charges_base(self.client)}/{charge_id}/refunds\"\n    body: Dict[str, Any] = {\"amount\": amount} if amount is not None else {}\n    djson(\"charges.refund body\", body)\n    resp = self.client.post(path, json=body, idempotency_key=idempotency_key)\n    return Refund.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.ChargesAPI.wait_until_terminal","title":"<code>wait_until_terminal(charge_id, *, server_polling=True, timeout_s=90, interval_s=2.0)</code>","text":"<p>Block until the charge reaches a terminal state.</p> <p>If server_polling=True, perform a single GET with polling=true. Otherwise, poll client-side every interval_s until timeout_s is reached.</p> Source code in <code>univapay\\resources\\charges.py</code> <pre><code>def wait_until_terminal(\n    self,\n    charge_id: str,\n    *,\n    server_polling: bool = True,\n    timeout_s: int = 90,\n    interval_s: float = 2.0,\n) -&gt; Charge:\n    \"\"\"\n    Block until the charge reaches a terminal state.\n\n    If server_polling=True, perform a single GET with polling=true.\n    Otherwise, poll client-side every interval_s until timeout_s is reached.\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n    if timeout_s &lt;= 0 or interval_s &lt;= 0:\n        raise ValueError(\"timeout_s and interval_s must be positive.\")\n\n    dprint(\"charges.wait_until_terminal()\", {\n        \"charge_id\": charge_id,\n        \"server_polling\": server_polling,\n        \"timeout_s\": timeout_s,\n        \"interval_s\": interval_s,\n    })\n\n    if server_polling:\n        ch = self.get(charge_id, polling=True)\n        dprint(\"charges.wait_until_terminal: server-polling returned\", {\"status\": ch.status})\n        return ch\n\n    deadline = time.time() + timeout_s\n    while True:\n        ch = self.get(charge_id)\n        status_norm = (ch.status or \"\").lower()\n        if status_norm in _TERMINAL_STATES:\n            dprint(\"charges.wait_until_terminal -&gt; terminal\", {\"status\": ch.status})\n            return ch\n        if time.time() &gt;= deadline:\n            dprint(\"charges.wait_until_terminal -&gt; timeout\", {\"last_status\": ch.status})\n            return ch\n        time.sleep(interval_s)\n</code></pre>"},{"location":"API/#univapay.resources.SubscriptionsAPI.client","title":"<code>client = client</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.SubscriptionsAPI.__init__","title":"<code>__init__(client)</code>","text":"Source code in <code>univapay\\resources\\subscriptions.py</code> <pre><code>def __init__(self, client: UnivapayClient):\n    self.client = client\n    dprint(\"subscriptions.__init__()\", {\"base_path\": _subs_base(self.client)})\n</code></pre>"},{"location":"API/#univapay.resources.SubscriptionsAPI.cancel","title":"<code>cancel(subscription_id, *, idempotency_key=None, termination_mode=None, **extra)</code>","text":"<p>Cancel a subscription and return the updated Subscription resource.</p> <p>Primary attempt: POST /subscriptions/{id}/cancel. Fallback: PATCH /subscriptions/{id} with {'termination_mode': 'immediate'|'on_next_payment'}</p> Source code in <code>univapay\\resources\\subscriptions.py</code> <pre><code>def cancel(\n    self,\n    subscription_id: str,\n    *,\n    idempotency_key: Optional[str] = None,\n    termination_mode: Optional[str] = None,\n    **extra: Any,\n) -&gt; Subscription:\n    \"\"\"\n    Cancel a subscription and return the updated Subscription resource.\n\n    Primary attempt: POST /subscriptions/{id}/cancel.\n    Fallback: PATCH /subscriptions/{id} with {'termination_mode': 'immediate'|'on_next_payment'}\n    \"\"\"\n    _validate_id(\"subscription_id\", subscription_id)\n    dprint(\n        \"subscriptions.cancel()\",\n        {\"subscription_id\": subscription_id, \"idempotency_key_present\": bool(idempotency_key)},\n    )\n    base = _subs_base(self.client)\n    path = f\"{base}/{subscription_id}/cancel\"\n    body = {**(extra or {})}\n    if termination_mode:\n        body.setdefault(\"termination_mode\", termination_mode)\n    djson(\"subscriptions.cancel body\", body if body else {})\n    try:\n        resp = self.client.post(path, json=body, idempotency_key=idempotency_key)\n        return Subscription.model_validate(resp)\n    except Exception as e:\n        # Fallback for accounts without /cancel endpoint\n        try:\n            from ..errors import UnivapayHTTPError  # local import to avoid cycle\n            not_found = isinstance(e, UnivapayHTTPError) and e.status in (404, 405)\n        except Exception:\n            not_found = False\n        if not_found:\n            dprint(\"subscriptions.cancel fallback -&gt; PATCH\", {\"subscription_id\": subscription_id})\n            patch_body: Dict[str, Any] = {**(extra or {})}\n            patch_body.setdefault(\"termination_mode\", termination_mode or \"immediate\")\n            djson(\"subscriptions.cancel PATCH body\", patch_body)\n            resp2 = self.client.patch(f\"{base}/{subscription_id}\", json=patch_body, idempotency_key=idempotency_key)\n            return Subscription.model_validate(resp2)\n        raise\n</code></pre>"},{"location":"API/#univapay.resources.SubscriptionsAPI.create","title":"<code>create(*, token_id, amount, period, currency='jpy', metadata=None, start_on=None, idempotency_key=None, **extra)</code>","text":"<p>Create a subscription using a subscription-capable transaction token.</p> Source code in <code>univapay\\resources\\subscriptions.py</code> <pre><code>def create(\n    self,\n    *,\n    token_id: str,\n    amount: int,\n    period: str,\n    currency: str = \"jpy\",\n    metadata: Optional[Dict[str, Any]] = None,\n    start_on: Optional[str] = None,  # ISO date (YYYY-MM-DD)\n    idempotency_key: Optional[str] = None,\n    **extra: Any,\n) -&gt; Subscription:\n    \"\"\"Create a subscription using a subscription-capable transaction token.\"\"\"\n    _validate_token(token_id)\n    _validate_amount(amount)\n    currency = _validate_currency(currency)\n    period = _validate_period(period)\n\n    dprint(\n        \"subscriptions.create()\",\n        {\n            \"token_id\": token_id,\n            \"amount\": amount,\n            \"period\": period,\n            \"currency\": currency,\n            \"start_on\": start_on,\n            \"idempotency_key_present\": bool(idempotency_key),\n        },\n    )\n\n    body = SubscriptionCreate(\n        transaction_token_id=token_id,\n        amount=amount,\n        currency=currency,\n        period=period,\n        start_on=start_on,\n    ).model_dump(by_alias=True, exclude_none=True)\n\n    if metadata:\n        body[\"metadata\"] = metadata\n    body.update(extra or {})\n\n    djson(\"subscriptions.create body\", body)\n    resp = self.client.post(_subs_base(self.client), json=body, idempotency_key=idempotency_key)\n    return Subscription.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.SubscriptionsAPI.get","title":"<code>get(subscription_id, *, polling=False)</code>","text":"<p>Retrieve a subscription. If polling=True, server may block until steady/terminal state.</p> Source code in <code>univapay\\resources\\subscriptions.py</code> <pre><code>def get(self, subscription_id: str, *, polling: bool = False) -&gt; Subscription:\n    \"\"\"Retrieve a subscription. If polling=True, server may block until steady/terminal state.\"\"\"\n    _validate_id(\"subscription_id\", subscription_id)\n    dprint(\"subscriptions.get()\", {\"subscription_id\": subscription_id, \"polling\": polling})\n    resp = self.client.get(f\"{_subs_base(self.client)}/{subscription_id}\", polling=polling)\n    return Subscription.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.SubscriptionsAPI.wait_until_terminal","title":"<code>wait_until_terminal(subscription_id, *, server_polling=False, timeout_s=60, interval_s=2.0)</code>","text":"<p>Return once the subscription is in a terminal-ish state.</p> Flow <p>1) Quick GET without polling; if already terminal-ish (e.g., 'current'), return immediately. 2) If server_polling=True, do a single GET with polling=true (server may block). 3) Else, client-side poll until terminal or timeout.</p> Source code in <code>univapay\\resources\\subscriptions.py</code> <pre><code>def wait_until_terminal(\n    self,\n    subscription_id: str,\n    *,\n    server_polling: bool = False,  # default False to avoid long blocks by default\n    timeout_s: int = 60,\n    interval_s: float = 2.0,\n) -&gt; Subscription:\n    \"\"\"\n    Return once the subscription is in a terminal-ish state.\n\n    Flow:\n      1) Quick GET without polling; if already terminal-ish (e.g., 'current'), return immediately.\n      2) If server_polling=True, do a single GET with polling=true (server may block).\n      3) Else, client-side poll until terminal or timeout.\n    \"\"\"\n    _validate_id(\"subscription_id\", subscription_id)\n    if timeout_s &lt;= 0 or interval_s &lt;= 0:\n        raise ValueError(\"timeout_s and interval_s must be positive.\")\n\n    dprint(\n        \"subscriptions.wait_until_terminal()\",\n        {\n            \"subscription_id\": subscription_id,\n            \"server_polling\": server_polling,\n            \"timeout_s\": timeout_s,\n            \"interval_s\": interval_s,\n        },\n    )\n\n    # Step 1: quick check\n    sub = self.get(subscription_id, polling=False)\n    if _is_terminal(sub.status):\n        dprint(\"subscriptions.wait_until_terminal: already terminal-ish\", {\"status\": sub.status})\n        return sub\n\n    # Step 2: server polling if requested\n    if server_polling:\n        sub_p = self.get(subscription_id, polling=True)\n        dprint(\"subscriptions.wait_until_terminal: server-polling returned\", {\"status\": sub_p.status})\n        return sub_p\n\n    # Step 3: client-side loop\n    deadline = time.time() + timeout_s\n    last = sub\n    while time.time() &lt; deadline:\n        time.sleep(interval_s)\n        last = self.get(subscription_id, polling=False)\n        if _is_terminal(last.status):\n            dprint(\"subscriptions.wait_until_terminal: reached terminal-ish\", {\"status\": last.status})\n            return last\n\n    dprint(\n        \"subscriptions.wait_until_terminal timeout\",\n        {\"subscription_id\": subscription_id, \"last_status\": getattr(last, \"status\", None)},\n    )\n    return last\n</code></pre>"},{"location":"API/#univapay.resources.RefundsAPI.client","title":"<code>client = client</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.RefundsAPI.__init__","title":"<code>__init__(client)</code>","text":"Source code in <code>univapay\\resources\\refunds.py</code> <pre><code>def __init__(self, client: UnivapayClient):\n    self.client = client\n</code></pre>"},{"location":"API/#univapay.resources.RefundsAPI.create","title":"<code>create(charge_id, *, amount=None, reason=None, idempotency_key=None, **extra)</code>","text":"<p>Create a refund.</p>"},{"location":"API/#univapay.resources.RefundsAPI.create--parameters","title":"Parameters","text":"<p>charge_id : str     The charge to refund. amount : Optional[int]     Amount in minor units. If None, a full refund may be performed (API/account dependent). reason : Optional[str]     Optional reason string for audit trails. idempotency_key : Optional[str]     Recommended: pass a stable id for safe retries.</p>"},{"location":"API/#univapay.resources.RefundsAPI.create--returns","title":"Returns","text":"<p>Refund</p> Source code in <code>univapay\\resources\\refunds.py</code> <pre><code>def create(\n    self,\n    charge_id: str,\n    *,\n    amount: Optional[int] = None,\n    reason: Optional[str] = None,\n    idempotency_key: Optional[str] = None,\n    **extra: Any,\n) -&gt; Refund:\n    \"\"\"\n    Create a refund.\n\n    Parameters\n    ----------\n    charge_id : str\n        The charge to refund.\n    amount : Optional[int]\n        Amount in minor units. If None, a full refund may be performed (API/account dependent).\n    reason : Optional[str]\n        Optional reason string for audit trails.\n    idempotency_key : Optional[str]\n        Recommended: pass a stable id for safe retries.\n\n    Returns\n    -------\n    Refund\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n    if amount is not None:\n        _validate_amount(amount)\n\n    payload: Dict[str, Any] = {}\n    if amount is not None:\n        payload[\"amount\"] = amount\n    if reason:\n        payload[\"reason\"] = reason\n    payload.update(extra)\n\n    dprint(\n        \"refunds.create()\",\n        {\n            \"charge_id\": charge_id,\n            \"amount\": amount,\n            \"reason\": reason,\n            \"idempotency_key_present\": bool(idempotency_key),\n        },\n    )\n    djson(\"refunds.create body\", payload)\n\n    resp = self.client.post(_base(self.client, charge_id), json=payload, idempotency_key=idempotency_key)\n    return Refund.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.RefundsAPI.create_full_refund","title":"<code>create_full_refund(charge_id, *, reason=None, idempotency_key=None, **extra)</code>","text":"<p>Convenience: request a full refund (omit <code>amount</code>).</p> Source code in <code>univapay\\resources\\refunds.py</code> <pre><code>def create_full_refund(\n    self,\n    charge_id: str,\n    *,\n    reason: Optional[str] = None,\n    idempotency_key: Optional[str] = None,\n    **extra: Any,\n) -&gt; Refund:\n    \"\"\"\n    Convenience: request a full refund (omit `amount`).\n    \"\"\"\n    dprint(\"refunds.create_full_refund()\", {\"charge_id\": charge_id})\n    return self.create(\n        charge_id,\n        amount=None,\n        reason=reason,\n        idempotency_key=idempotency_key,\n        **extra,\n    )\n</code></pre>"},{"location":"API/#univapay.resources.RefundsAPI.create_partial_refund","title":"<code>create_partial_refund(charge_id, *, amount, reason=None, idempotency_key=None, **extra)</code>","text":"<p>Convenience: request a partial refund (requires <code>amount</code>).</p> Source code in <code>univapay\\resources\\refunds.py</code> <pre><code>def create_partial_refund(\n    self,\n    charge_id: str,\n    *,\n    amount: int,\n    reason: Optional[str] = None,\n    idempotency_key: Optional[str] = None,\n    **extra: Any,\n) -&gt; Refund:\n    \"\"\"\n    Convenience: request a partial refund (requires `amount`).\n    \"\"\"\n    dprint(\"refunds.create_partial_refund()\", {\"charge_id\": charge_id, \"amount\": amount})\n    _validate_amount(amount)\n    return self.create(\n        charge_id,\n        amount=amount,\n        reason=reason,\n        idempotency_key=idempotency_key,\n        **extra,\n    )\n</code></pre>"},{"location":"API/#univapay.resources.RefundsAPI.get","title":"<code>get(charge_id, refund_id, *, polling=False)</code>","text":"<p>Fetch a specific refund. If <code>polling=True</code>, server may block until a terminal state (when supported).</p> Source code in <code>univapay\\resources\\refunds.py</code> <pre><code>def get(self, charge_id: str, refund_id: str, *, polling: bool = False) -&gt; Refund:\n    \"\"\"\n    Fetch a specific refund. If `polling=True`, server may block until a terminal state (when supported).\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n    _validate_id(\"refund_id\", refund_id)\n\n    path = f\"{_base(self.client, charge_id)}/{refund_id}\"\n    dprint(\"refunds.get()\", {\"charge_id\": charge_id, \"refund_id\": refund_id, \"polling\": polling})\n    resp = self.client.get(path, polling=polling)\n    return Refund.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.RefundsAPI.list","title":"<code>list(charge_id, *, limit=None, cursor=None, extra_params=None)</code>","text":"<p>List refunds for a charge (passthrough dict to preserve API fields/pagination).</p> Source code in <code>univapay\\resources\\refunds.py</code> <pre><code>def list(\n    self,\n    charge_id: str,\n    *,\n    limit: Optional[int] = None,\n    cursor: Optional[str] = None,\n    extra_params: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    List refunds for a charge (passthrough dict to preserve API fields/pagination).\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n\n    params: Dict[str, Any] = {}\n    if limit is not None:\n        if not isinstance(limit, int) or limit &lt;= 0:\n            raise ValueError(\"limit must be a positive integer.\")\n        params[\"limit\"] = limit\n    if cursor:\n        params[\"cursor\"] = cursor\n    if extra_params:\n        params.update(extra_params)\n\n    dprint(\"refunds.list()\", {\"charge_id\": charge_id, \"params\": params})\n    resp = self.client.get(_base(self.client, charge_id), params=params)\n    djson(\"refunds.list response\", resp)\n    return resp\n</code></pre>"},{"location":"API/#univapay.resources.RefundsAPI.wait_until_terminal","title":"<code>wait_until_terminal(charge_id, refund_id, *, server_polling=True, timeout_s=60, interval_s=2.0)</code>","text":"<p>Block until the refund reaches a terminal-ish status.</p> <p>If server_polling=True, perform a single GET with polling=true. Otherwise, poll client-side every <code>interval_s</code> until <code>timeout_s</code> is reached.</p> Source code in <code>univapay\\resources\\refunds.py</code> <pre><code>def wait_until_terminal(\n    self,\n    charge_id: str,\n    refund_id: str,\n    *,\n    server_polling: bool = True,\n    timeout_s: int = 60,\n    interval_s: float = 2.0,\n) -&gt; Refund:\n    \"\"\"\n    Block until the refund reaches a terminal-ish status.\n\n    If server_polling=True, perform a single GET with polling=true.\n    Otherwise, poll client-side every `interval_s` until `timeout_s` is reached.\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n    _validate_id(\"refund_id\", refund_id)\n    if timeout_s &lt;= 0 or interval_s &lt;= 0:\n        raise ValueError(\"timeout_s and interval_s must be positive.\")\n\n    dprint(\n        \"refunds.wait_until_terminal()\",\n        {\n            \"charge_id\": charge_id,\n            \"refund_id\": refund_id,\n            \"server_polling\": server_polling,\n            \"timeout_s\": timeout_s,\n            \"interval_s\": interval_s,\n        },\n    )\n\n    if server_polling:\n        # Single blocking call if the API supports server-side polling\n        return self.get(charge_id, refund_id, polling=True)\n\n    # Client-side polling loop\n    deadline = time.time() + timeout_s\n    last = self.get(charge_id, refund_id, polling=False)\n    if _is_terminal(last.status):\n        dprint(\"refunds.wait_until_terminal: already terminal-ish\", {\"status\": last.status})\n        return last\n\n    while time.time() &lt; deadline:\n        time.sleep(interval_s)\n        last = self.get(charge_id, refund_id, polling=False)\n        if _is_terminal(last.status):\n            dprint(\"refunds.wait_until_terminal -&gt; terminal-ish\", {\"status\": last.status})\n            return last\n\n    dprint(\"refunds.wait_until_terminal -&gt; timeout\", {\"last_status\": getattr(last, \"status\", None)})\n    return last\n</code></pre>"},{"location":"API/#univapay.resources.CancelsAPI.client","title":"<code>client = client</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.CancelsAPI.__init__","title":"<code>__init__(client)</code>","text":"Source code in <code>univapay\\resources\\cancels.py</code> <pre><code>def __init__(self, client: UnivapayClient):\n    self.client = client\n</code></pre>"},{"location":"API/#univapay.resources.CancelsAPI.cancel_charge","title":"<code>cancel_charge(charge_id, *, idempotency_key=None, **extra)</code>","text":"<p>Cancel a charge (or an authorization prior to capture).</p>"},{"location":"API/#univapay.resources.CancelsAPI.cancel_charge--parameters","title":"Parameters","text":"<p>charge_id : str     The charge identifier to cancel. idempotency_key : Optional[str]     Recommended for safe retries. **extra :     Additional fields supported by your Univapay account.</p>"},{"location":"API/#univapay.resources.CancelsAPI.cancel_charge--returns","title":"Returns","text":"<p>Charge     The canceled/voided charge resource (typed).</p> Source code in <code>univapay\\resources\\cancels.py</code> <pre><code>def cancel_charge(\n    self,\n    charge_id: str,\n    *,\n    idempotency_key: Optional[str] = None,\n    **extra: Any,\n) -&gt; Charge:\n    \"\"\"\n    Cancel a charge (or an authorization prior to capture).\n\n    Parameters\n    ----------\n    charge_id : str\n        The charge identifier to cancel.\n    idempotency_key : Optional[str]\n        Recommended for safe retries.\n    **extra :\n        Additional fields supported by your Univapay account.\n\n    Returns\n    -------\n    Charge\n        The canceled/voided charge resource (typed).\n    \"\"\"\n    _validate_id(\"charge_id\", charge_id)\n\n    path = f\"{self.client._path('charges')}/{charge_id}/cancel\"\n    dprint(\n        \"cancels.cancel_charge()\",\n        {\"charge_id\": charge_id, \"idempotency_key_present\": bool(idempotency_key)},\n    )\n    body = {**extra} if extra else {}\n    djson(\"cancels.cancel_charge body\", body)\n\n    resp = self.client.post(path, json=body, idempotency_key=idempotency_key)\n    return Charge.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.CancelsAPI.void_authorization","title":"<code>void_authorization(charge_id, *, idempotency_key=None, **extra)</code>","text":"<p>Void a previously authorized (not yet captured) charge.</p>"},{"location":"API/#univapay.resources.CancelsAPI.void_authorization--notes","title":"Notes","text":"<p>Many Univapay setups map this to the same route as cancel:     POST /charges/{charge_id}/cancel</p>"},{"location":"API/#univapay.resources.CancelsAPI.void_authorization--returns","title":"Returns","text":"<p>Charge</p> Source code in <code>univapay\\resources\\cancels.py</code> <pre><code>def void_authorization(\n    self,\n    charge_id: str,\n    *,\n    idempotency_key: Optional[str] = None,\n    **extra: Any,\n) -&gt; Charge:\n    \"\"\"\n    Void a previously authorized (not yet captured) charge.\n\n    Notes\n    -----\n    Many Univapay setups map this to the same route as cancel:\n        POST /charges/{charge_id}/cancel\n\n    Returns\n    -------\n    Charge\n    \"\"\"\n    dprint(\"cancels.void_authorization() -&gt; cancel_charge()\", {\"charge_id\": charge_id})\n    return self.cancel_charge(\n        charge_id,\n        idempotency_key=idempotency_key,\n        **extra,\n    )\n</code></pre>"},{"location":"API/#univapay.resources.TokensAPI.client","title":"<code>client = client</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.TokensAPI.__init__","title":"<code>__init__(client)</code>","text":"Source code in <code>univapay\\resources\\tokens.py</code> <pre><code>def __init__(self, client: UnivapayClient):\n    self.client = client\n    dprint(\"tokens.__init__()\", {\"base_path\": _tokens_base(self.client)})\n</code></pre>"},{"location":"API/#univapay.resources.TokensAPI.get","title":"<code>get(token_id)</code>","text":"<p>Fetch a transaction token by ID.</p>"},{"location":"API/#univapay.resources.TokensAPI.get--parameters","title":"Parameters","text":"<p>token_id : str     The transaction token id (from the FE widget callback).</p>"},{"location":"API/#univapay.resources.TokensAPI.get--returns","title":"Returns","text":"<p>TransactionToken     A typed model of the token response (extra fields are preserved).</p>"},{"location":"API/#univapay.resources.TokensAPI.get--raises","title":"Raises","text":"<p>ValueError     If token_id is empty/invalid. UnivapayHTTPError     If the HTTP call fails.</p> Source code in <code>univapay\\resources\\tokens.py</code> <pre><code>def get(self, token_id: str) -&gt; TransactionToken:\n    \"\"\"\n    Fetch a transaction token by ID.\n\n    Parameters\n    ----------\n    token_id : str\n        The transaction token id (from the FE widget callback).\n\n    Returns\n    -------\n    TransactionToken\n        A typed model of the token response (extra fields are preserved).\n\n    Raises\n    ------\n    ValueError\n        If token_id is empty/invalid.\n    UnivapayHTTPError\n        If the HTTP call fails.\n    \"\"\"\n    _validate_id(\"token_id\", token_id)\n    dprint(\"tokens.get()\", {\"token_id\": token_id})\n    resp = self.client.get(f\"{_tokens_base(self.client)}/{token_id}\")\n    djson(\"tokens.get response\", resp)\n    return TransactionToken.model_validate(resp)\n</code></pre>"},{"location":"API/#univapay.resources.TokensAPI.try_get","title":"<code>try_get(token_id)</code>","text":"<p>Like <code>get()</code> but returns None if the token does not exist (HTTP 404). Propagates other HTTP errors.</p> Source code in <code>univapay\\resources\\tokens.py</code> <pre><code>def try_get(self, token_id: str) -&gt; Optional[TransactionToken]:\n    \"\"\"\n    Like `get()` but returns None if the token does not exist (HTTP 404).\n    Propagates other HTTP errors.\n    \"\"\"\n    _validate_id(\"token_id\", token_id)\n    dprint(\"tokens.try_get()\", {\"token_id\": token_id})\n    try:\n        return self.get(token_id)\n    except UnivapayHTTPError as e:\n        if e.status == 404:\n            dprint(\"tokens.try_get: not found\", {\"token_id\": token_id})\n            return None\n        dprint(\"tokens.try_get: error\", {\"status\": e.status})\n        raise\n</code></pre>"},{"location":"API/#webhooks","title":"Webhooks","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic Univapay webhook envelope (best-effort typed). We keep it permissive so unknown fields won't break you.</p> Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>class WebhookEvent(BaseModel):\n    \"\"\"\n    Generic Univapay webhook envelope (best-effort typed).\n    We keep it permissive so unknown fields won't break you.\n    \"\"\"\n    id: Optional[str] = None\n    type: Optional[str] = None\n    resource_type: Optional[str] = Field(None, alias=\"resourceType\")\n    created_on: Optional[str] = Field(None, alias=\"createdOn\")\n    created: Optional[str] = None  # some payloads use `created`\n    mode: Optional[str] = None     # \"test\" / \"live\", etc.\n\n    # Full raw payload for convenience\n    data: Dict[str, Any] = Field(default_factory=dict)\n\n    model_config = ConfigDict(extra=\"allow\", populate_by_name=True)\n</code></pre> Minimal event router <p>router = WebhookRouter() @router.on(\"charge.successful\") def _h(e): ...</p> Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>class WebhookRouter:\n    \"\"\"\n    Minimal event router:\n        router = WebhookRouter()\n        @router.on(\"charge.successful\")\n        def _h(e): ...\n        # wildcard handler:\n        @router.on(\"*\")\n        def _all(e): ...\n\n        info, event = verify_and_parse(body=..., headers=..., secret=...)\n        results = router.dispatch(event)\n    \"\"\"\n    def __init__(self) -&gt; None:\n        self._map: Dict[str, List[Handler]] = {}\n\n    def on(self, event_type: str) -&gt; Callable[[Handler], Handler]:\n        if not event_type or not isinstance(event_type, str):\n            raise ValueError(\"event_type must be a non-empty string (or '*').\")\n\n        def _decorator(func: Handler) -&gt; Handler:\n            self._map.setdefault(event_type, []).append(func)\n            dprint(\"webhooks.router.on()\", {\"event_type\": event_type, \"handler\": getattr(func, \"__name__\", \"handler\")})\n            return func\n\n        return _decorator\n\n    def add(self, event_type: str, func: Handler) -&gt; None:\n        self._map.setdefault(event_type, []).append(func)\n        dprint(\"webhooks.router.add()\", {\"event_type\": event_type, \"handler\": getattr(func, \"__name__\", \"handler\")})\n\n    def handlers_for(self, event_type: Optional[str]) -&gt; Iterable[Handler]:\n        if not event_type:\n            # no type =&gt; only wildcard\n            return self._map.get(\"*\", [])\n        return [*self._map.get(event_type, []), *self._map.get(\"*\", [])]\n\n    def dispatch(self, event: WebhookEvent) -&gt; List[Any]:\n        dprint(\"webhooks.router.dispatch()\", {\"type\": event.type})\n        out: List[Any] = []\n        for fn in self.handlers_for(event.type):\n            try:\n                res = fn(event)\n                out.append(res)\n            except Exception as e:\n                dprint(\"webhooks.router handler error\", {\"handler\": getattr(fn, \"__name__\", \"handler\"), \"error\": repr(e)})\n                out.append(e)\n        return out\n</code></pre> <p>Parse and (optionally) verify a Univapay webhook.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, bytes, bytearray]</code> <p>raw request body (bytes/str).</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>incoming HTTP headers (case-insensitive handling).</p> required <code>secret</code> <code>Optional[Union[str, bytes]]</code> <p>your webhook signing secret (None + skip_verification=True for dev).</p> <code>None</code> <code>header_name</code> <code>Optional[str]</code> <p>force a specific signature header name (optional).</p> <code>None</code> <code>tolerance_s</code> <code>int</code> <p>timestamp tolerance when signature contains a timestamp.</p> <code>5 * 60</code> <code>skip_verification</code> <code>bool</code> <p>set True for local/dev only.</p> <code>False</code> <p>Returns:</p> Type Description <code>WebhookEvent</code> <p>WebhookEvent</p> Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>def parse_event(\n    *,\n    body: Union[str, bytes, bytearray],\n    headers: Mapping[str, str],\n    secret: Optional[Union[str, bytes]] = None,\n    header_name: Optional[str] = None,\n    tolerance_s: int = 5 * 60,\n    skip_verification: bool = False,\n) -&gt; WebhookEvent:\n    \"\"\"\n    Parse and (optionally) verify a Univapay webhook.\n\n    Args:\n      body: raw request body (bytes/str).\n      headers: incoming HTTP headers (case-insensitive handling).\n      secret: your webhook signing secret (None + skip_verification=True for dev).\n      header_name: force a specific signature header name (optional).\n      tolerance_s: timestamp tolerance when signature contains a timestamp.\n      skip_verification: set True for local/dev only.\n\n    Returns:\n      WebhookEvent\n    \"\"\"\n    dprint(\"webhooks.parse_event() begin\", {\n        \"skip_verification\": skip_verification,\n        \"header_override\": header_name,\n    })\n\n    # Verify signature first (unless skipped)\n    verify_signature(\n        payload=body,\n        headers=headers,\n        secret=secret,\n        header_name=header_name,\n        tolerance_s=tolerance_s,\n        skip_verification=skip_verification,\n    )\n\n    # Decode JSON\n    if isinstance(body, (bytes, bytearray)):\n        raw_text = body.decode(\"utf-8\", errors=\"replace\")\n    else:\n        raw_text = body\n\n    try:\n        payload = json.loads(raw_text) if raw_text else {}\n    except Exception as e:\n        raise WebhookVerificationError(f\"invalid JSON body: {e}\") from e\n\n    djson(\"webhooks.parse_event() payload\", payload)\n\n    # Lift common fields if present\n    ev = WebhookEvent(\n        id=payload.get(\"id\"),\n        type=payload.get(\"type\") or payload.get(\"event\") or payload.get(\"event_type\"),\n        resource_type=payload.get(\"resourceType\") or payload.get(\"resource_type\"),\n        created_on=payload.get(\"createdOn\") or payload.get(\"created_on\"),\n        created=payload.get(\"created\"),\n        mode=payload.get(\"mode\"),\n        data=payload,\n    )\n    djson(\"webhooks.parse_event() event\", ev.model_dump(mode=\"json\"))\n    return ev\n</code></pre> <p>Verify HMAC signatures using common header conventions. Returns details dict (including which header matched). Raises WebhookVerificationError on failure (unless skip_verification=True).</p> DEV NOTE <ul> <li>If <code>secret</code> is None/empty and skip_verification=False -&gt; raise.</li> <li>If <code>skip_verification=True</code>, we log and return without checking.</li> </ul> Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>def verify_signature(\n    *,\n    payload: Union[str, bytes, bytearray],\n    headers: Mapping[str, str],\n    secret: Optional[Union[str, bytes]],\n    header_name: Optional[str] = None,\n    tolerance_s: int = 5 * 60,   # used when header has a timestamp like t=...\n    skip_verification: bool = False,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Verify HMAC signatures using common header conventions.\n    Returns details dict (including which header matched).\n    Raises WebhookVerificationError on failure (unless skip_verification=True).\n\n    DEV NOTE:\n      - If `secret` is None/empty and skip_verification=False -&gt; raise.\n      - If `skip_verification=True`, we log and return without checking.\n    \"\"\"\n    dprint(\"webhooks.verify_signature() start\", {\n        \"skip_verification\": skip_verification,\n        \"header_name_override\": bool(header_name),\n        \"tolerance_s\": tolerance_s,\n    })\n\n    if skip_verification:\n        dprint(\"webhooks.verify_signature() skipped (dev mode)\")\n        return {\"skipped\": True}\n\n    if not secret:\n        raise WebhookVerificationError(\"webhook secret missing\")\n\n    # Find signature header\n    sig_value, found_name = _find_sig_header(headers, header_name)\n    dprint(\"webhooks.verify_signature() header found\", {\"header\": found_name, \"value_len\": len(sig_value)})\n\n    # Normalize payload for hashing\n    if isinstance(payload, (bytes, bytearray)):\n        body_bytes = bytes(payload)\n    else:\n        body_bytes = payload.encode(\"utf-8\")\n\n    # Parse header\n    parsed = _parse_sig_header(sig_value)\n    djson(\"webhooks.verify_signature() parsed header\", parsed)\n\n    ok = False\n    reason = \"no_match\"\n\n    # Case 1: timestamped (t=..., v1=...) - assume v1 is SHA-256 HMAC of \"t.&lt;body&gt;\"\n    if \"t\" in parsed and \"v1\" in parsed:\n        t_val = parsed[\"t\"]\n        sig_hex = parsed[\"v1\"]\n        try:\n            ts = int(t_val)\n            now = int(time.time())\n        except Exception as e:\n            raise WebhookVerificationError(f\"signature verification failed: bad_timestamp:{e}\")\n\n        # Enforce tolerance first\n        if abs(now - ts) &gt; int(tolerance_s):\n            dprint(\"webhooks.verify_signature() timestamp out of tolerance\", {\"now\": now, \"ts\": ts})\n            raise WebhookVerificationError(\"signature verification failed: timestamp_out_of_tolerance\")\n\n        # canonical message is \"&lt;timestamp&gt;.&lt;body&gt;\"\n        signed_payload = f\"{t_val}.\".encode(\"utf-8\") + body_bytes\n        comp = _hmac_hex(secret, signed_payload, \"sha256\")\n        ok = _cmp(comp, sig_hex)\n        if not ok:\n            reason = \"mismatch\"\n\n    # Case 2: sha256=... (GitHub-like)\n    elif \"sha256\" in parsed:\n        comp = _hmac_hex(secret, body_bytes, \"sha256\")\n        ok = _cmp(comp, parsed[\"sha256\"])\n        if not ok:\n            reason = \"mismatch\"\n\n    # Case 3: sha1=... (rare but supported for flexibility)\n    elif \"sha1\" in parsed:\n        comp = _hmac_hex(secret, body_bytes, \"sha1\")\n        ok = _cmp(comp, parsed[\"sha1\"])\n        if not ok:\n            reason = \"mismatch\"\n\n    # Case 4: raw hex in header\n    elif \"raw\" in parsed:\n        comp = _hmac_hex(secret, body_bytes, \"sha256\")\n        ok = _cmp(comp, parsed[\"raw\"])\n        if not ok:\n            reason = \"mismatch\"\n\n    else:\n        reason = \"unsupported_header_format\"\n\n    dprint(\"webhooks.verify_signature() result\", {\"ok\": ok, \"reason\": reason, \"header\": found_name})\n    if not ok:\n        raise WebhookVerificationError(f\"signature verification failed: {reason}\")\n\n    return {\"ok\": True, \"header\": found_name, \"reason\": \"verified\"}\n</code></pre>"},{"location":"API/#univapay.resources.WebhookEvent.created","title":"<code>created = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.WebhookEvent.created_on","title":"<code>created_on = Field(None, alias='createdOn')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.WebhookEvent.data","title":"<code>data = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.WebhookEvent.id","title":"<code>id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.WebhookEvent.mode","title":"<code>mode = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.WebhookEvent.model_config","title":"<code>model_config = ConfigDict(extra='allow', populate_by_name=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.WebhookEvent.resource_type","title":"<code>resource_type = Field(None, alias='resourceType')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.WebhookEvent.type","title":"<code>type = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/#univapay.resources.WebhookRouter--wildcard-handler","title":"wildcard handler:","text":"<p>@router.on(\"*\") def _all(e): ...</p> <p>info, event = verify_and_parse(body=..., headers=..., secret=...) results = router.dispatch(event)</p>"},{"location":"API/#univapay.resources.WebhookRouter.__init__","title":"<code>__init__()</code>","text":"Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._map: Dict[str, List[Handler]] = {}\n</code></pre>"},{"location":"API/#univapay.resources.WebhookRouter.add","title":"<code>add(event_type, func)</code>","text":"Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>def add(self, event_type: str, func: Handler) -&gt; None:\n    self._map.setdefault(event_type, []).append(func)\n    dprint(\"webhooks.router.add()\", {\"event_type\": event_type, \"handler\": getattr(func, \"__name__\", \"handler\")})\n</code></pre>"},{"location":"API/#univapay.resources.WebhookRouter.dispatch","title":"<code>dispatch(event)</code>","text":"Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>def dispatch(self, event: WebhookEvent) -&gt; List[Any]:\n    dprint(\"webhooks.router.dispatch()\", {\"type\": event.type})\n    out: List[Any] = []\n    for fn in self.handlers_for(event.type):\n        try:\n            res = fn(event)\n            out.append(res)\n        except Exception as e:\n            dprint(\"webhooks.router handler error\", {\"handler\": getattr(fn, \"__name__\", \"handler\"), \"error\": repr(e)})\n            out.append(e)\n    return out\n</code></pre>"},{"location":"API/#univapay.resources.WebhookRouter.handlers_for","title":"<code>handlers_for(event_type)</code>","text":"Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>def handlers_for(self, event_type: Optional[str]) -&gt; Iterable[Handler]:\n    if not event_type:\n        # no type =&gt; only wildcard\n        return self._map.get(\"*\", [])\n    return [*self._map.get(event_type, []), *self._map.get(\"*\", [])]\n</code></pre>"},{"location":"API/#univapay.resources.WebhookRouter.on","title":"<code>on(event_type)</code>","text":"Source code in <code>univapay\\resources\\webhooks.py</code> <pre><code>def on(self, event_type: str) -&gt; Callable[[Handler], Handler]:\n    if not event_type or not isinstance(event_type, str):\n        raise ValueError(\"event_type must be a non-empty string (or '*').\")\n\n    def _decorator(func: Handler) -&gt; Handler:\n        self._map.setdefault(event_type, []).append(func)\n        dprint(\"webhooks.router.on()\", {\"event_type\": event_type, \"handler\": getattr(func, \"__name__\", \"handler\")})\n        return func\n\n    return _decorator\n</code></pre>"},{"location":"API/#widgets","title":"Widgets","text":""},{"location":"API/#univapay.widgets.__all__","title":"<code>__all__ = ['build_one_time_widget_config', 'build_subscription_widget_config', 'build_recurring_widget_config', 'build_widget_bundle_envelope', 'widget_loader_src', 'to_json']</code>  <code>module-attribute</code>","text":""},{"location":"API/#univapay.widgets.build_one_time_widget_config","title":"<code>build_one_time_widget_config(*, amount, form_id, button_id, description, widget_key='oneTime', app_jwt=None, env=None, base_config=None, callbacks=None, api=None, payment_methods=None, **extra)</code>","text":"<p>Build FE config for a ONE-TIME payment widget. - Supports enabling/disabling card/paidy/online brands/konbini/bank_transfer via <code>payment_methods</code>.</p> Source code in <code>univapay\\widgets.py</code> <pre><code>def build_one_time_widget_config(\n    *,\n    amount: int,\n    form_id: str,\n    button_id: str,\n    description: str,\n    widget_key: str = \"oneTime\",\n    app_jwt: Optional[str] = None,\n    env: Mapping[str, str] | None = None,\n    base_config: Optional[Mapping[str, Any]] = None,\n    callbacks: Optional[Mapping[str, Any]] = None,\n    api: Optional[Mapping[str, Any]] = None,\n    payment_methods: Optional[Mapping[str, Any]] = None,\n    **extra: Any,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Build FE config for a ONE-TIME payment widget.\n    - Supports enabling/disabling card/paidy/online brands/konbini/bank_transfer via `payment_methods`.\n    \"\"\"\n    _validate_amount(amount)\n    _validate_id(\"form_id\", form_id)\n    _validate_id(\"button_id\", button_id)\n    _validate_id(\"description\", description)\n\n    app_id = _require_env_app_id(app_jwt, env)\n    methods = _normalize_payment_methods(payment_methods)\n    widget = {\n        \"checkout\": \"payment\",\n        \"amount\": amount,\n        \"formId\": form_id.strip(),\n        \"buttonId\": button_id.strip(),\n        \"description\": description.strip(),\n        # New: pass method toggles for FE to filter options\n        \"paymentMethods\": methods,\n        **extra,\n    }\n    dprint(\"widgets: build_one_time\", {\"widget_key\": widget_key, \"amount\": amount})\n    djson(\"widgets.one_time.widget\", widget)\n    return _envelope_single(\n        app_id=app_id,\n        widget_key=widget_key,\n        widget=widget,\n        base_config=base_config,\n        callbacks=callbacks,\n        api=api,\n    )\n</code></pre>"},{"location":"API/#univapay.widgets.build_recurring_widget_config","title":"<code>build_recurring_widget_config(*, amount, form_id, button_id, description, widget_key='recurring', app_jwt=None, env=None, base_config=None, callbacks=None, api=None, payment_methods=None, **extra)</code>","text":"<p>Build FE config for a RECURRING payment widget (tokenize card for merchant-initiated charges). - Recurring is effectively a card-token flow; other methods will be debug-warned if supplied.</p> Source code in <code>univapay\\widgets.py</code> <pre><code>def build_recurring_widget_config(\n    *,\n    amount: int,\n    form_id: str,\n    button_id: str,\n    description: str,\n    widget_key: str = \"recurring\",\n    app_jwt: Optional[str] = None,\n    env: Mapping[str, str] | None = None,\n    base_config: Optional[Mapping[str, Any]] = None,\n    callbacks: Optional[Mapping[str, Any]] = None,\n    api: Optional[Mapping[str, Any]] = None,\n    payment_methods: Optional[Mapping[str, Any]] = None,\n    **extra: Any,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Build FE config for a RECURRING payment widget (tokenize card for merchant-initiated charges).\n    - Recurring is effectively a card-token flow; other methods will be debug-warned if supplied.\n    \"\"\"\n    _validate_amount(amount)\n    _validate_id(\"form_id\", form_id)\n    _validate_id(\"button_id\", button_id)\n    _validate_id(\"description\", description)\n\n    app_id = _require_env_app_id(app_jwt, env)\n    methods = _normalize_payment_methods(payment_methods)\n    _warn_incompatible(\"recurring\", methods)\n\n    widget = {\n        \"checkout\": \"payment\",\n        \"tokenType\": \"recurring\",\n        \"amount\": amount,\n        \"formId\": form_id.strip(),\n        \"buttonId\": button_id.strip(),\n        \"description\": description.strip(),\n        \"paymentMethods\": methods,\n        **extra,\n    }\n    dprint(\"widgets: build_recurring\", {\"widget_key\": widget_key, \"amount\": amount})\n    djson(\"widgets.recurring.widget\", widget)\n    return _envelope_single(\n        app_id=app_id,\n        widget_key=widget_key,\n        widget=widget,\n        base_config=base_config,\n        callbacks=callbacks,\n        api=api,\n    )\n</code></pre>"},{"location":"API/#univapay.widgets.build_subscription_widget_config","title":"<code>build_subscription_widget_config(*, amount, period, form_id, button_id, description, widget_key='subscription', app_jwt=None, env=None, base_config=None, callbacks=None, api=None, payment_methods=None, **extra)</code>","text":"<p>Build FE config for a SUBSCRIPTION payment widget. - Typically card; other methods will be debug-warned if supplied.</p> Source code in <code>univapay\\widgets.py</code> <pre><code>def build_subscription_widget_config(\n    *,\n    amount: int,\n    period: str,                 # e.g., \"monthly\", \"semiannually\", \"yearly\"\n    form_id: str,\n    button_id: str,\n    description: str,\n    widget_key: str = \"subscription\",\n    app_jwt: Optional[str] = None,\n    env: Mapping[str, str] | None = None,\n    base_config: Optional[Mapping[str, Any]] = None,\n    callbacks: Optional[Mapping[str, Any]] = None,\n    api: Optional[Mapping[str, Any]] = None,\n    payment_methods: Optional[Mapping[str, Any]] = None,\n    **extra: Any,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Build FE config for a SUBSCRIPTION payment widget.\n    - Typically card; other methods will be debug-warned if supplied.\n    \"\"\"\n    _validate_amount(amount)\n    p = _validate_period(period)\n    _validate_id(\"form_id\", form_id)\n    _validate_id(\"button_id\", button_id)\n    _validate_id(\"description\", description)\n\n    app_id = _require_env_app_id(app_jwt, env)\n    methods = _normalize_payment_methods(payment_methods)\n    _warn_incompatible(\"subscription\", methods)\n\n    widget = {\n        \"checkout\": \"payment\",\n        \"tokenType\": \"subscription\",\n        \"subscriptionPeriod\": p,\n        \"amount\": amount,\n        \"formId\": form_id.strip(),\n        \"buttonId\": button_id.strip(),\n        \"description\": description.strip(),\n        \"paymentMethods\": methods,\n        **extra,\n    }\n    dprint(\"widgets: build_subscription\", {\"widget_key\": widget_key, \"amount\": amount, \"period\": p})\n    djson(\"widgets.subscription.widget\", widget)\n    return _envelope_single(\n        app_id=app_id,\n        widget_key=widget_key,\n        widget=widget,\n        base_config=base_config,\n        callbacks=callbacks,\n        api=api,\n    )\n</code></pre>"},{"location":"API/#univapay.widgets.build_widget_bundle_envelope","title":"<code>build_widget_bundle_envelope(*, widgets, app_jwt=None, env=None, base_config=None, callbacks=None, api=None)</code>","text":"Build a single payload with multiple widgets <p>widgets = {   \"oneTimeAlpha\": {...},         # result of builders below (already normalized)   \"subscriptionSemiannual\": {...},   \"recurringVault\": {...} }</p> Source code in <code>univapay\\widgets.py</code> <pre><code>def build_widget_bundle_envelope(\n    *,\n    widgets: Mapping[str, Mapping[str, Any]],\n    app_jwt: Optional[str] = None,\n    env: Mapping[str, str] | None = None,\n    base_config: Optional[Mapping[str, Any]] = None,\n    callbacks: Optional[Mapping[str, Any]] = None,\n    api: Optional[Mapping[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Build a single payload with multiple widgets:\n      widgets = {\n        \"oneTimeAlpha\": {...},         # result of builders below (already normalized)\n        \"subscriptionSemiannual\": {...},\n        \"recurringVault\": {...}\n      }\n    \"\"\"\n    app_id = _require_env_app_id(app_jwt, env)\n    payload = {\n        \"appId\": app_id,\n        \"baseConfig\": _normalize_base_config(base_config),\n        \"widgets\": {k: dict(v) for k, v in widgets.items()},\n        \"callbacks\": _normalize_callbacks(callbacks),\n        \"api\": _normalize_api(api),\n    }\n    dprint(\"widgets: bundle envelope built\", {\"count\": len(widgets)})\n    djson(\"widgets.envelope\", {**payload, \"appId\": _mask_token(app_id)})\n    return payload\n</code></pre>"},{"location":"API/#univapay.widgets.to_json","title":"<code>to_json(payload, *, pretty=False)</code>","text":"<p>Serialize any widget envelope to JSON (useful in tests or manual output).</p> Source code in <code>univapay\\widgets.py</code> <pre><code>def to_json(payload: Dict[str, Any], *, pretty: bool = False) -&gt; str:\n    \"\"\"\n    Serialize any widget envelope to JSON (useful in tests or manual output).\n    \"\"\"\n    s = json.dumps(\n        payload,\n        ensure_ascii=False,\n        indent=2 if pretty else None,\n        separators=None if pretty else (\",\", \":\"),\n    )\n    dprint(\"widgets: to_json length\", {\"chars\": len(s)})\n    return s\n</code></pre>"},{"location":"API/#univapay.widgets.widget_loader_src","title":"<code>widget_loader_src(env=None)</code>","text":"<p>Return the official Univapay widget loader URL, optionally overridden by env.</p> <p>Env override key: \"UNIVAPAY_WIDGET_URL\" Default: \"https://widget.univapay.com/client/checkout.js\"</p> Source code in <code>univapay\\widgets.py</code> <pre><code>def widget_loader_src(env: Mapping[str, str] | None = None) -&gt; str:\n    \"\"\"\n    Return the official Univapay widget loader URL, optionally overridden by env.\n\n    Env override key: \"UNIVAPAY_WIDGET_URL\"\n    Default: \"https://widget.univapay.com/client/checkout.js\"\n    \"\"\"\n    env = env or os.environ\n    return (env.get(\"UNIVAPAY_WIDGET_URL\") or \"https://widget.univapay.com/client/checkout.js\").strip()\n</code></pre>"},{"location":"API/#errors","title":"Errors","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all Univapay SDK errors.</p> Source code in <code>univapay\\errors.py</code> <pre><code>class UnivapaySDKError(Exception):\n    \"\"\"Base exception for all Univapay SDK errors.\"\"\"\n    pass\n</code></pre> <p>               Bases: <code>UnivapaySDKError</code></p> <p>Raised when configuration/credentials are invalid or missing.</p> Source code in <code>univapay\\errors.py</code> <pre><code>class UnivapayConfigError(UnivapaySDKError):\n    \"\"\"Raised when configuration/credentials are invalid or missing.\"\"\"\n    pass\n</code></pre> <p>               Bases: <code>UnivapaySDKError</code></p> <p>Unified HTTP error for API requests.</p> <p>               Bases: <code>UnivapaySDKError</code></p> <p>Raised for webhook signature/format errors.</p> Source code in <code>univapay\\errors.py</code> <pre><code>class UnivapayWebhookError(UnivapaySDKError):\n    \"\"\"Raised for webhook signature/format errors.\"\"\"\n    pass\n</code></pre>"},{"location":"API/#univapay.errors.UnivapayHTTPError--attributes","title":"Attributes","text":"<p>status : int     HTTP status code (or -1 for network errors). payload : Any     Parsed JSON or fallback body describing the error (kept verbatim). request_id : Optional[str]     Server-provided request correlation id, if available. method : Optional[str]     Best-effort HTTP method that triggered the error (if provided). url : Optional[str]     Best-effort URL that triggered the error (if provided).</p>"},{"location":"API/#univapay.errors.UnivapayHTTPError--convenience","title":"Convenience","text":"<p>.code            -&gt; extracted error code (if present in payload) .message_text    -&gt; human-friendly error message .retryable       -&gt; bool, True if typical transient status (429, 500-504) .to_dict()       -&gt; sanitized summary dict for logging</p> Source code in <code>univapay\\errors.py</code> <pre><code>class UnivapayHTTPError(UnivapaySDKError):\n    \"\"\"\n    Unified HTTP error for API requests.\n\n    Attributes\n    ----------\n    status : int\n        HTTP status code (or -1 for network errors).\n    payload : Any\n        Parsed JSON or fallback body describing the error (kept verbatim).\n    request_id : Optional[str]\n        Server-provided request correlation id, if available.\n    method : Optional[str]\n        Best-effort HTTP method that triggered the error (if provided).\n    url : Optional[str]\n        Best-effort URL that triggered the error (if provided).\n\n    Convenience\n    -----------\n    .code            -&gt; extracted error code (if present in payload)\n    .message_text    -&gt; human-friendly error message\n    .retryable       -&gt; bool, True if typical transient status (429, 500-504)\n    .to_dict()       -&gt; sanitized summary dict for logging\n    \"\"\"\n\n    def __init__(\n        self,\n        status: int,\n        payload: Any,\n        request_id: Optional[str] = None,\n        *,\n        method: Optional[str] = None,\n        url: Optional[str] = None,\n    ):\n        self.status = int(status)\n        self.payload = payload\n        self.request_id = request_id\n        self.method = method\n        self.url = url\n\n        # Debug output (payload is printed via djson; avoid leaking secrets)\n        dprint(\"UnivapayHTTPError\", {\n            \"status\": self.status,\n            \"request_id\": self.request_id,\n            \"method\": self.method,\n            \"url\": self.url,\n        })\n        djson(\"UnivapayHTTPError payload\", self.payload)\n\n        super().__init__(self._message())\n\n    # ---------------- convenience properties ----------------\n\n    @property\n    def retryable(self) -&gt; bool:\n        \"\"\"Return True for common transient HTTP statuses.\"\"\"\n        return self.status in (429, 500, 502, 503, 504)\n\n    @property\n    def code(self) -&gt; Optional[str]:\n        \"\"\"Try to extract a structured error code from the payload if present.\"\"\"\n        p = self.payload\n        try:\n            if isinstance(p, dict):\n                # common shapes: {\"code\": \"...\"} or {\"error\": {\"code\": \"...\"}} or {\"error_code\": \"...\"}\n                if isinstance(p.get(\"error\"), dict) and \"code\" in p[\"error\"]:\n                    return str(p[\"error\"][\"code\"])\n                if \"code\" in p:\n                    return str(p[\"code\"])\n                if \"error_code\" in p:\n                    return str(p[\"error_code\"])\n            return None\n        except Exception:\n            return None\n\n    @property\n    def message_text(self) -&gt; str:\n        \"\"\"\n        Human-friendly message guessed from payload.\n        Keeps it short and safe for logs.\n        \"\"\"\n        p = self.payload\n        # strings straight through\n        if isinstance(p, str):\n            return p.strip() or \"error\"\n        # dict heuristics\n        if isinstance(p, dict):\n            for key in (\"message\", \"error\", \"detail\", \"description\"):\n                val = p.get(key)\n                if isinstance(val, str) and val.strip():\n                    return val.strip()\n                # nested {\"error\": {\"message\": \"...\"}}\n                if isinstance(val, dict):\n                    nested = val.get(\"message\") or val.get(\"detail\") or val.get(\"description\")\n                    if isinstance(nested, str) and nested.strip():\n                        return nested.strip()\n            # fallback: very short JSON preview\n            try:\n                import json\n                s = json.dumps(p, ensure_ascii=False)\n                return s if len(s) &lt;= 240 else s[:237] + \"...\"\n            except Exception:\n                return \"error\"\n        # other types\n        try:\n            return str(p)\n        except Exception:\n            return \"error\"\n\n    # ---------------- rendering &amp; serialization ----------------\n\n    def _message(self) -&gt; str:\n        rid = f\" req_id={self.request_id}\" if self.request_id else \"\"\n        meth = f\" {self.method}\" if self.method else \"\"\n        url = f\" {self.url}\" if self.url else \"\"\n        code = f\" code={self.code}\" if self.code else \"\"\n        msg = self.message_text\n        # Keep single-line &amp; compact; payload already printed by djson()\n        return f\"HTTP {self.status}{meth}{url}{rid}{code}: {msg}\"\n\n    def __str__(self) -&gt; str:\n        return self._message()\n\n    def __repr__(self) -&gt; str:\n        return f\"UnivapayHTTPError(status={self.status}, request_id={self.request_id!r}, code={self.code!r})\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Sanitized summary for logs/telemetry; includes only non-sensitive fields.\"\"\"\n        return {\n            \"status\": self.status,\n            \"request_id\": self.request_id,\n            \"method\": self.method,\n            \"url\": self.url,\n            \"code\": self.code,\n            \"message\": self.message_text,\n            \"retryable\": self.retryable,\n        }\n</code></pre>"},{"location":"API/#univapay.errors.UnivapayHTTPError.code","title":"<code>code</code>  <code>property</code>","text":"<p>Try to extract a structured error code from the payload if present.</p>"},{"location":"API/#univapay.errors.UnivapayHTTPError.message_text","title":"<code>message_text</code>  <code>property</code>","text":"<p>Human-friendly message guessed from payload. Keeps it short and safe for logs.</p>"},{"location":"API/#univapay.errors.UnivapayHTTPError.method","title":"<code>method = method</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.errors.UnivapayHTTPError.payload","title":"<code>payload = payload</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.errors.UnivapayHTTPError.request_id","title":"<code>request_id = request_id</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.errors.UnivapayHTTPError.retryable","title":"<code>retryable</code>  <code>property</code>","text":"<p>Return True for common transient HTTP statuses.</p>"},{"location":"API/#univapay.errors.UnivapayHTTPError.status","title":"<code>status = int(status)</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.errors.UnivapayHTTPError.url","title":"<code>url = url</code>  <code>instance-attribute</code>","text":""},{"location":"API/#univapay.errors.UnivapayHTTPError.__init__","title":"<code>__init__(status, payload, request_id=None, *, method=None, url=None)</code>","text":"Source code in <code>univapay\\errors.py</code> <pre><code>def __init__(\n    self,\n    status: int,\n    payload: Any,\n    request_id: Optional[str] = None,\n    *,\n    method: Optional[str] = None,\n    url: Optional[str] = None,\n):\n    self.status = int(status)\n    self.payload = payload\n    self.request_id = request_id\n    self.method = method\n    self.url = url\n\n    # Debug output (payload is printed via djson; avoid leaking secrets)\n    dprint(\"UnivapayHTTPError\", {\n        \"status\": self.status,\n        \"request_id\": self.request_id,\n        \"method\": self.method,\n        \"url\": self.url,\n    })\n    djson(\"UnivapayHTTPError payload\", self.payload)\n\n    super().__init__(self._message())\n</code></pre>"},{"location":"API/#univapay.errors.UnivapayHTTPError.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>univapay\\errors.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"UnivapayHTTPError(status={self.status}, request_id={self.request_id!r}, code={self.code!r})\"\n</code></pre>"},{"location":"API/#univapay.errors.UnivapayHTTPError.__str__","title":"<code>__str__()</code>","text":"Source code in <code>univapay\\errors.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._message()\n</code></pre>"},{"location":"API/#univapay.errors.UnivapayHTTPError.to_dict","title":"<code>to_dict()</code>","text":"<p>Sanitized summary for logs/telemetry; includes only non-sensitive fields.</p> Source code in <code>univapay\\errors.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Sanitized summary for logs/telemetry; includes only non-sensitive fields.\"\"\"\n    return {\n        \"status\": self.status,\n        \"request_id\": self.request_id,\n        \"method\": self.method,\n        \"url\": self.url,\n        \"code\": self.code,\n        \"message\": self.message_text,\n        \"retryable\": self.retryable,\n    }\n</code></pre>"},{"location":"Configuration/","title":"Configuration","text":"<p>Server-side API calls require both a Univapay App Token (JWT) and a server secret. You can supply them via environment variables or explicitly when constructing <code>UnivapayConfig</code>.</p>"},{"location":"Configuration/#environment-variables","title":"Environment Variables","text":"Variable Required Default Notes <code>UNIVAPAY_JWT</code> yes \u2014 FE App Token (JWT). Also used in Authorization with secret. <code>UNIVAPAY_SECRET</code> yes \u2014 Server secret \u2014 keep safe. <code>UNIVAPAY_STORE_ID</code> often \u2014 Required for most store-scoped calls. <code>UNIVAPAY_BASE_URL</code> no <code>https://api.univapay.com</code> Set alternative envs. Trailing slash is stripped. <code>UNIVAPAY_TIMEOUT</code> no <code>30</code> Client timeout (seconds). <code>UNIVAPAY_DEBUG</code> no <code>1</code> Controls SDK debug logging (1/0). <code>UNIVAPAY_RETRIES</code> no <code>0</code> Simple retry count for transient errors. <code>UNIVAPAY_BACKOFF</code> no <code>0.5</code> Exponential backoff factor (seconds). <code>UNIVAPAY_WIDGET_URL</code> no official Optional override for widget loader URL. <p>Create a <code>.env</code> file if you installed with the <code>dotenv</code> extra:</p> <pre><code>UNIVAPAY_JWT=your_app_token_jwt\nUNIVAPAY_SECRET=your_server_secret\nUNIVAPAY_STORE_ID=your_store_id\nUNIVAPAY_BASE_URL=https://api.univapay.com\nUNIVAPAY_DEBUG=1\n</code></pre>"},{"location":"Configuration/#programmatic-config","title":"Programmatic Config","text":"<pre><code>from univapay import UnivapayConfig\n\ncfg = UnivapayConfig(\n    jwt=\"...\",\n    secret=\"...\",\n    store_id=\"...\",\n    base_url=\"https://api.univapay.com\",\n    timeout=30,\n    debug=True,\n    retries=1,\n    backoff_factor=0.5,\n).validate()\n</code></pre> <p>If either <code>jwt</code> or <code>secret</code> is missing, the SDK raises <code>UnivapayConfigError</code>.</p>"},{"location":"Configuration/#masked-diagnostics","title":"Masked Diagnostics","text":"<p>You can log a safe, masked view of your config for debugging:</p> <pre><code>print(cfg.masked())\n</code></pre> <p>The SDK also prints sanitized debug logs when <code>UNIVAPAY_DEBUG=1</code>.</p>"},{"location":"Errors-and-Debugging/","title":"Errors and Debugging","text":""},{"location":"Errors-and-Debugging/#debug-logging","title":"Debug Logging","text":"<p>Set <code>UNIVAPAY_DEBUG=1</code> (default during development) to enable SDK debug logs. Logs include sanitized headers and truncated JSON bodies. Set <code>UNIVAPAY_DEBUG=0</code> to disable.</p> <p>Runtime toggles:</p> <pre><code>from univapay import dprint, djson, set_debug_enabled\n\nset_debug_enabled(True)\n</code></pre>"},{"location":"Errors-and-Debugging/#exceptions","title":"Exceptions","text":"<ul> <li><code>UnivapaySDKError</code>: base class for SDK exceptions.</li> <li><code>UnivapayConfigError</code>: configuration/credentials issues (e.g., missing <code>UNIVAPAY_JWT</code>).</li> <li><code>UnivapayHTTPError</code>: unified HTTP error for REST calls.</li> <li><code>UnivapayWebhookError</code>: webhook signature/format errors.</li> </ul>"},{"location":"Errors-and-Debugging/#univapayhttperror","title":"UnivapayHTTPError","text":"<p>Attrs:</p> <ul> <li><code>status</code>: HTTP status (or <code>-1</code> on network errors)</li> <li><code>payload</code>: parsed JSON or text fallback</li> <li><code>request_id</code>: server-provided request id, if available</li> <li><code>retryable</code>: True on 429/500/502/503/504</li> <li><code>message_text</code>: a short, user-friendly message derived from payload</li> </ul> <pre><code>from univapay.errors import UnivapayHTTPError\n\ntry:\n    charge = charges.create_one_time(token_id=\"...\", amount=1000, currency=\"jpy\")\nexcept UnivapayHTTPError as e:\n    print(e.status, e.message_text, e.request_id, e.retryable)\n    # Optional structured log\n    print(e.to_dict())\n</code></pre>"},{"location":"Errors-and-Debugging/#rate-limits-and-request-ids","title":"Rate Limits and Request IDs","text":"<p>Successful responses include a <code>_meta</code> field with rate-limit headers (when provided by the API) and the request id. This is helpful for troubleshooting and support.</p>"},{"location":"Examples/","title":"Examples","text":"<p>This repository includes small runnable scripts and a Flask demo app to help you test common flows quickly.</p>"},{"location":"Examples/#setup","title":"Setup","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate   # Windows: .venv\\\\Scripts\\\\activate\npython -m pip install -U pip\npython -m pip install -e \".[dotenv]\"\n\n# Export env or create .env at project root\nexport UNIVAPAY_JWT=...\nexport UNIVAPAY_SECRET=...\nexport UNIVAPAY_STORE_ID=...\n</code></pre>"},{"location":"Examples/#scripts","title":"Scripts","text":"<ul> <li><code>examples/charge_one_time.py</code>: create a one-time charge</li> <li><code>examples/charge_recurring.py</code>: create a charge with a recurring token</li> <li><code>examples/charge_capture.py</code>: capture a previously authorized charge</li> <li><code>examples/charge_cancel.py</code>: cancel/void a charge</li> <li><code>examples/refund_create.py</code>: create a refund (full or partial)</li> <li><code>examples/refund_list.py</code>: list refunds for a charge</li> <li><code>examples/subscription_create.py</code>: create a subscription</li> <li><code>examples/subscription_get.py</code>: get a subscription</li> <li><code>examples/subscription_cancel.py</code>: cancel a subscription</li> <li><code>examples/token_check.py</code>: fetch a transaction token by id</li> <li><code>examples/smoke_api.py</code>: quick connectivity check for API</li> <li><code>examples/smoke_widget.py</code>: show widget payloads on stdout</li> <li><code>examples/webhook_verify_sample.py</code>: verify a webhook signature from sample data</li> </ul> <p>Each script supports basic CLI args (see <code>examples/_common.py</code>).</p>"},{"location":"Examples/#flask-demo","title":"Flask Demo","text":"<p>Path: <code>examples/univapay_flask_demo/</code></p> <ul> <li><code>app.py</code>: minimal backend with routes to render widget pages and handle server-side calls (charges/subscriptions)</li> <li><code>.env.example</code>: sample env settings; copy to <code>.env</code> and fill values</li> <li><code>static/</code> and <code>templates/</code>: example frontend pages using the official widget</li> </ul> <p>Run:</p> <pre><code>cd examples/univapay_flask_demo\npython -m pip install -r requirements.txt\ncp .env.example .env  # then edit\nflask --app app run --debug\n</code></pre> <p>Open http://127.0.0.1:5000 to try the demo.</p>"},{"location":"Quickstart/","title":"Quickstart","text":"<p>This guide gets you from zero to a working server-side integration using the Univapay-Python SDK.</p>"},{"location":"Quickstart/#1-install","title":"1) Install","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\npython -m pip install -U pip\npython -m pip install -e \".[dotenv]\"\n</code></pre>"},{"location":"Quickstart/#2-configure","title":"2) Configure","text":"<p>Set the following environment variables (or use a <code>.env</code> file):</p> <ul> <li><code>UNIVAPAY_JWT</code> - App Token (JWT) </li> <li><code>UNIVAPAY_SECRET</code> - Server secret </li> <li><code>UNIVAPAY_STORE_ID</code> - Your store id (often required) </li> </ul> <p>Optional:</p> <ul> <li><code>UNIVAPAY_BASE_URL</code> (default <code>https://api.univapay.com</code>)</li> <li><code>UNIVAPAY_TIMEOUT</code> (default 30)</li> <li><code>UNIVAPAY_DEBUG</code> (default 1)</li> </ul>"},{"location":"Quickstart/#3-make-a-simple-charge","title":"3) Make a simple charge","text":"<pre><code>from univapay import UnivapayConfig, UnivapayClient\nfrom univapay.resources import ChargesAPI\nfrom univapay.utils import make_idempotency_key\n\ncfg = UnivapayConfig().validate()\nwith UnivapayClient(cfg, retries=1, backoff_factor=0.5) as client:\n    charges = ChargesAPI(client)\n    charge = charges.create_one_time(\n        token_id=\"token_from_widget\",\n        amount=12000,  # minor units\n        currency=\"jpy\",\n        capture=True,\n        idempotency_key=make_idempotency_key(\"quickstart\"),\n    )\n    print(\"charge:\", charge.id, charge.status)\n</code></pre>"},{"location":"Quickstart/#4-webhook-verification","title":"4) Webhook verification","text":"<pre><code>from flask import Flask, request, jsonify\nfrom univapay.resources import parse_event, WebhookVerificationError\n\napp = Flask(__name__)\nWEBHOOK_SECRET = \"your_webhook_secret\"\n\n@app.post(\"/webhook/univapay\")\ndef webhook():\n    try:\n        ev = parse_event(\n            body=request.get_data(cache=False, as_text=False),\n            headers=request.headers,\n            secret=WEBHOOK_SECRET,\n            tolerance_s=300,\n            skip_verification=False,\n        )\n        return jsonify({\"ok\": True, \"type\": ev.type})\n    except WebhookVerificationError as e:\n        return jsonify({\"ok\": False, \"error\": str(e)}), 400\n</code></pre>"},{"location":"Quickstart/#5-frontend-widget-config","title":"5) Frontend widget config","text":"<pre><code>from univapay.widgets import build_one_time_widget_config, to_json\n\npayload = build_one_time_widget_config(\n    amount=12000,\n    form_id=\"form-one-time\",\n    button_id=\"btn-one-time\",\n    description=\"Product A - One-time\",\n)\nprint(to_json(payload, pretty=True))\n</code></pre> <p>Next: see Using with Python for common flows and API Reference for details.</p>"},{"location":"Using-with-Django-and-DRF/","title":"Using with Django &amp; DRF","text":"<p>This guide shows how to integrate the Univapay-Python SDK with a typical Django + DRF stack.</p>"},{"location":"Using-with-Django-and-DRF/#install","title":"Install","text":"<pre><code>pip install djangorestframework\npip install -e \".[dotenv]\"\n</code></pre>"},{"location":"Using-with-Django-and-DRF/#settings","title":"Settings","text":"<p>Set environment variables (or use <code>python-dotenv</code> in <code>manage.py</code>/<code>wsgi.py</code>):</p> <pre><code>UNIVAPAY_JWT=...\nUNIVAPAY_SECRET=...\nUNIVAPAY_STORE_ID=...\nUNIVAPAY_BASE_URL=https://api.univapay.com\n</code></pre>"},{"location":"Using-with-Django-and-DRF/#client-dependency","title":"Client dependency","text":"<pre><code># app/univapay_client.py\nfrom univapay import UnivapayConfig, UnivapayClient\n\ndef get_client() -&gt; UnivapayClient:\n    cfg = UnivapayConfig().validate()\n    return UnivapayClient(cfg, retries=1, backoff_factor=0.5)\n</code></pre>"},{"location":"Using-with-Django-and-DRF/#drf-views","title":"DRF views","text":"<pre><code># app/views.py\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom univapay.resources import ChargesAPI, SubscriptionsAPI\nfrom .univapay_client import get_client\n\n@api_view([\"POST\"])\ndef create_charge(request):\n    token_id = request.data.get(\"tokenId\")\n    amount = int(request.data.get(\"amount\", 0))\n    currency = request.data.get(\"currency\", \"jpy\")\n    if not token_id or amount &lt;= 0:\n        return Response({\"error\": \"tokenId and amount required\"}, status=status.HTTP_400_BAD_REQUEST)\n\n    client = get_client()\n    try:\n        with client as c:\n            charges = ChargesAPI(c)\n            ch = charges.create_one_time(token_id=token_id, amount=amount, currency=currency)\n            return Response(ch.model_dump())\n    finally:\n        client.close()\n\n@api_view([\"POST\"])\ndef create_subscription(request):\n    token_id = request.data.get(\"tokenId\")\n    amount = int(request.data.get(\"amount\", 0))\n    currency = request.data.get(\"currency\", \"jpy\")\n    period = request.data.get(\"period\")\n    if not token_id or amount &lt;= 0 or not period:\n        return Response({\"error\": \"tokenId, amount, period required\"}, status=status.HTTP_400_BAD_REQUEST)\n\n    client = get_client()\n    try:\n        with client as c:\n            subs = SubscriptionsAPI(c)\n            s = subs.create(token_id=token_id, amount=amount, period=period, currency=currency)\n            return Response(s.model_dump())\n    finally:\n        client.close()\n</code></pre>"},{"location":"Using-with-Django-and-DRF/#webhook-view","title":"Webhook view","text":"<pre><code># app/webhooks.py\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom univapay.resources import parse_event, WebhookVerificationError\nimport os\n\nWEBHOOK_SECRET = os.getenv(\"UNIVAPAY_WEBHOOK_SECRET\")\n\n@api_view([\"POST\"])\ndef univapay_webhook(request):\n    try:\n        ev = parse_event(body=request.body, headers=request.headers, secret=WEBHOOK_SECRET, tolerance_s=300)\n        # TODO: dispatch ev.type to handlers, update DB, etc.\n        return Response({\"ok\": True, \"type\": ev.type})\n    except WebhookVerificationError as e:\n        return Response({\"ok\": False, \"error\": str(e)}, status=status.HTTP_400_BAD_REQUEST)\n</code></pre>"},{"location":"Using-with-Django-and-DRF/#urls","title":"URLs","text":"<pre><code># app/urls.py\nfrom django.urls import path\nfrom . import views, webhooks\n\nurlpatterns = [\n    path(\"api/charges\", views.create_charge),\n    path(\"api/subscriptions\", views.create_subscription),\n    path(\"webhook/univapay\", webhooks.univapay_webhook),\n]\n</code></pre> <p>With this setup, your DRF API can accept tokens from the Univapay widget and create charges/subscriptions server-side, and receive webhook notifications.</p>"},{"location":"Using-with-FastAPI/","title":"Using with FastAPI","text":"<p>This guide shows how to wire Univapay-Python into a typical FastAPI app.</p>"},{"location":"Using-with-FastAPI/#install","title":"Install","text":"<pre><code>pip install fastapi uvicorn\npip install -e \".[dotenv]\"\n</code></pre>"},{"location":"Using-with-FastAPI/#settings","title":"Settings","text":"<p>Set environment variables (or use a <code>.env</code>):</p> <pre><code>UNIVAPAY_JWT=...\nUNIVAPAY_SECRET=...\nUNIVAPAY_STORE_ID=...\nUNIVAPAY_BASE_URL=https://api.univapay.com\n</code></pre>"},{"location":"Using-with-FastAPI/#client-dependency","title":"Client dependency","text":"<pre><code># deps.py\nfrom univapay import UnivapayConfig, UnivapayClient\n\ndef get_client() -&gt; UnivapayClient:\n    cfg = UnivapayConfig().validate()\n    return UnivapayClient(cfg, retries=1, backoff_factor=0.5)\n</code></pre>"},{"location":"Using-with-FastAPI/#routes","title":"Routes","text":"<pre><code># main.py\nfrom fastapi import FastAPI, Depends, HTTPException, Request\nfrom univapay.resources import ChargesAPI, SubscriptionsAPI, parse_event, WebhookVerificationError\nfrom .deps import get_client\n\napp = FastAPI()\n\n@app.post(\"/api/charges\")\nasync def create_charge(payload: dict, client = Depends(get_client)):\n    token_id = payload.get(\"tokenId\")\n    amount = int(payload.get(\"amount\", 0))\n    currency = payload.get(\"currency\", \"jpy\")\n    if not token_id or amount &lt;= 0:\n        raise HTTPException(status_code=400, detail=\"tokenId and amount required\")\n    with client as c:\n        ch = ChargesAPI(c).create_one_time(token_id=token_id, amount=amount, currency=currency)\n        return ch.model_dump()\n\n@app.post(\"/api/subscriptions\")\nasync def create_subscription(payload: dict, client = Depends(get_client)):\n    token_id = payload.get(\"tokenId\")\n    amount = int(payload.get(\"amount\", 0))\n    currency = payload.get(\"currency\", \"jpy\")\n    period = payload.get(\"period\")\n    if not token_id or amount &lt;= 0 or not period:\n        raise HTTPException(status_code=400, detail=\"tokenId, amount, period required\")\n    with client as c:\n        s = SubscriptionsAPI(c).create(token_id=token_id, amount=amount, period=period, currency=currency)\n        return s.model_dump()\n\n@app.post(\"/webhook/univapay\")\nasync def webhook(request: Request):\n    body = await request.body()\n    try:\n        ev = parse_event(body=body, headers=request.headers, secret=None, tolerance_s=300, skip_verification=True)\n        # TODO: dispatch `ev.type` to handlers, update DB, etc.\n        return {\"ok\": True, \"type\": ev.type}\n    except WebhookVerificationError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n</code></pre> <p>Run the app:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Use the SDK\u2019s widget builders on the server to create FE-safe JSON payloads for your frontend to pass into the official Univapay widget.</p>"},{"location":"Using-with-Python/","title":"Using with Python","text":"<p>This page covers typical server-side flows using the SDK.</p>"},{"location":"Using-with-Python/#setup","title":"Setup","text":"<pre><code>from univapay import UnivapayConfig, UnivapayClient\n\ncfg = UnivapayConfig().validate()\nclient = UnivapayClient(cfg, retries=1, backoff_factor=0.5)\n</code></pre>"},{"location":"Using-with-Python/#charges","title":"Charges","text":"<pre><code>from univapay.resources import ChargesAPI\nfrom univapay.utils import make_idempotency_key\n\ncharges = ChargesAPI(client)\n\n# One-time\nch = charges.create_one_time(\n    token_id=\"token_from_widget\",\n    amount=12000,\n    currency=\"jpy\",\n    capture=True,\n    idempotency_key=make_idempotency_key(\"one_time\"),\n)\n\n# Recurring (token_type=recurring)\nch2 = charges.create_recurring(\n    token_id=\"recurring_token\",\n    amount=30000,\n    currency=\"jpy\",\n)\n\n# Read / wait\nfetched = charges.get(ch.id)\nfinal = charges.wait_until_terminal(ch.id, server_polling=True)\n\n# Refund\nrefund = charges.refund(ch.id, amount=6000)\n</code></pre>"},{"location":"Using-with-Python/#subscriptions","title":"Subscriptions","text":"<pre><code>from univapay.resources import SubscriptionsAPI\n\nsubs = SubscriptionsAPI(client)\n\n# Create\ns = subs.create(\n    token_id=\"subscription_token\",\n    amount=59400,\n    period=\"semiannually\",\n    currency=\"jpy\",\n)\n\n# Read / wait\nnow = subs.get(s.id)\nsteady = subs.wait_until_terminal(s.id, server_polling=False, timeout_s=120)\n\n# Cancel (with fallback termination_mode if /cancel is not available)\ns2 = subs.cancel(s.id, termination_mode=\"immediate\")\n</code></pre>"},{"location":"Using-with-Python/#tokens","title":"Tokens","text":"<pre><code>from univapay.resources import TokensAPI\n\ntokens = TokensAPI(client)\nt = tokens.get(\"transaction_token_id\")\nprint(t.id, t.token_type, t.status)\n</code></pre>"},{"location":"Using-with-Python/#webhooks","title":"Webhooks","text":"<p>See Quickstart for a minimal Flask example. The SDK supports:</p> <ul> <li>Signature verification (timestamped, sha256, raw hex)</li> <li>Permissive event model that keeps unknown fields</li> </ul>"},{"location":"Using-with-Python/#widgets","title":"Widgets","text":"<pre><code>from univapay.widgets import (\n    build_one_time_widget_config,\n    build_subscription_widget_config,\n    build_recurring_widget_config,\n)\n\npayload = build_subscription_widget_config(\n    amount=59400,\n    period=\"semiannually\",\n    form_id=\"form-sub\",\n    button_id=\"btn-sub\",\n    description=\"6 Month Plan\",\n    payment_methods={\"card\": True},\n)\n</code></pre> <p>Next steps:</p> <ul> <li>See API Reference for detailed class/function docs.</li> <li>See framework guides: Django &amp; DRF, FastAPI.</li> </ul>"},{"location":"Webhooks/","title":"Webhooks","text":"<p>The SDK helps verify signatures, parse events, and dispatch handlers.</p>"},{"location":"Webhooks/#signature-verification","title":"Signature Verification","text":"<p><code>verify_signature</code> accepts common header formats. It tries these header names (case-insensitive) by default:</p> <ul> <li><code>X-Univapay-Signature</code></li> <li><code>X-Univapay-Webhook-Signature</code></li> <li><code>X-Signature</code></li> <li><code>X-Hub-Signature-256</code>, <code>X-Hub-Signature</code></li> </ul> <p>It supports formats like:</p> <ul> <li><code>t=TIMESTAMP,v1=HEX</code></li> <li><code>sha256=HEX</code> or <code>sha1=HEX</code></li> <li><code>HEX</code> (raw)</li> </ul> <p>Example:</p> <pre><code>from univapay.resources import verify_signature, WebhookVerificationError\n\ntry:\n    info = verify_signature(\n        payload=raw_body_bytes,\n        headers=request_headers,  # mapping of header-name -&gt; value\n        secret=WEBHOOK_SECRET,\n        tolerance_s=300,\n    )\n    print(info)  # includes header used, algorithm, computed vs. provided\nexcept WebhookVerificationError as e:\n    # return 400\n    print(\"Invalid signature:\", str(e))\n</code></pre>"},{"location":"Webhooks/#parse-event","title":"Parse Event","text":"<pre><code>from univapay.resources import parse_event\n\nev = parse_event(\n    body=raw_body_bytes,\n    headers=request_headers,\n    secret=WEBHOOK_SECRET,\n    tolerance_s=300,\n)\nprint(ev.type, ev.id)\nprint(ev.data)  # full raw payload\n</code></pre>"},{"location":"Webhooks/#verify-and-parse-together","title":"Verify and Parse Together","text":"<pre><code>from univapay.resources import verify_and_parse\n\ninfo, ev = verify_and_parse(\n    body=raw_body_bytes,\n    headers=request_headers,\n    secret=WEBHOOK_SECRET,\n    tolerance_s=300,\n)\n</code></pre>"},{"location":"Webhooks/#tiny-event-router","title":"Tiny Event Router","text":"<pre><code>from univapay.resources import WebhookRouter\n\nrouter = WebhookRouter()\n\n@router.on(\"charge.successful\")\ndef on_charge_success(e):\n    print(\"charge successful\", e.data.get(\"id\"))\n\n@router.on(\"*\")\ndef on_any(e):\n    print(\"event:\", e.type)\n\n# Later, after verify_and_parse(...)\nresults = router.dispatch(ev)\n</code></pre>"},{"location":"Webhooks/#framework-examples","title":"Framework Examples","text":"<ul> <li>Flask: see Quickstart and <code>examples/univapay_flask_demo/</code>.</li> <li>Django/DRF: see Using with Django &amp; DRF.</li> <li>FastAPI: see Using with FastAPI.</li> </ul>"},{"location":"Widgets/","title":"Widgets","text":"<p>The SDK builds FE-safe JSON payloads that your frontend can pass into the official Univapay widget (loader script). These payloads never include secrets and take the App Token (JWT) from env unless you override it explicitly.</p> <p>See also: <code>univapay.widgets</code> in the API reference.</p>"},{"location":"Widgets/#loader-script","title":"Loader Script","text":"<p>Default loader URL:</p> <pre><code>&lt;script src=\"https://widget.univapay.com/client/checkout.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Override via env: <code>UNIVAPAY_WIDGET_URL</code>.</p>"},{"location":"Widgets/#one-time-payment","title":"One-time Payment","text":"<pre><code>from univapay.widgets import build_one_time_widget_config, to_json\n\npayload = build_one_time_widget_config(\n    amount=12000,  # minor units (e.g., JPY)\n    form_id=\"form-one-time\",\n    button_id=\"btn-one-time\",\n    description=\"Product A - One-time\",\n    payment_methods={\"card\": True, \"online\": {\"pay_pay_online\": True}},\n)\nprint(to_json(payload, pretty=True))\n</code></pre> <p>Frontend wiring (vanilla):</p> <pre><code>&lt;form id=\"form-one-time\" method=\"POST\" action=\"/charge/one-time\"&gt;\n  &lt;button id=\"btn-one-time\"&gt;Pay&lt;/button&gt;\n\\&lt;/form&gt;\n&lt;script&gt;\n  // Render payload from your server (e.g., JSON endpoint).\n  // Then initialize the widget with that payload using the official API.\n&lt;/script&gt;\n</code></pre>"},{"location":"Widgets/#subscription","title":"Subscription","text":"<pre><code>from univapay.widgets import build_subscription_widget_config\n\npayload = build_subscription_widget_config(\n    amount=59400,\n    period=\"semiannually\",\n    form_id=\"form-sub\",\n    button_id=\"btn-sub\",\n    description=\"Six-month Plan\",\n    payment_methods={\"card\": True},\n)\n</code></pre>"},{"location":"Widgets/#recurring-tokenize-for-merchant-initiated-charges","title":"Recurring (Tokenize for Merchant-Initiated Charges)","text":"<pre><code>from univapay.widgets import build_recurring_widget_config\n\npayload = build_recurring_widget_config(\n    amount=30000,\n    form_id=\"form-recurring\",\n    button_id=\"btn-recurring\",\n    description=\"Recurring Billing\",\n    payment_methods={\"card\": True},\n)\n</code></pre>"},{"location":"Widgets/#payment-method-toggles","title":"Payment Method Toggles","text":"<p>You can enable/disable categories:</p> <ul> <li><code>card</code>: <code>True|False</code></li> <li><code>paidy</code>: <code>True|False</code></li> <li><code>konbini</code>: map of brands (e.g., <code>{\"seven_eleven\": True}</code>)</li> <li><code>bank_transfer</code>: map of brands (e.g., <code>{\"japan_post_bank\": True}</code>)</li> <li><code>online</code>: map of brands (e.g., <code>{\"pay_pay_online\": True, \"alipay_online\": True}</code>)</li> </ul> <p>Unknown keys are ignored with a debug note. The frontend is authoritative for filtering.</p>"},{"location":"Widgets/#event-hooks-frontend","title":"Event Hooks (Frontend)","text":"<pre><code>&lt;script&gt;\nwindow.addEventListener(\"univapay:opened\", (e) =&gt; console.log(\"opened\", e));\nwindow.addEventListener(\"univapay:closed\", (e) =&gt; console.log(\"closed\", e));\nwindow.addEventListener(\"univapay:success\", (e) =&gt; {\n  console.log(\"success\", e.detail); // tokenId and possibly chargeId/subscriptionId\n});\n&lt;/script&gt;\n</code></pre>"},{"location":"Widgets/#bundling-multiple-widgets","title":"Bundling Multiple Widgets","text":"<pre><code>from univapay.widgets import (\n    build_one_time_widget_config,\n    build_subscription_widget_config,\n    build_recurring_widget_config,\n    build_widget_bundle_envelope,\n)\n\none = build_one_time_widget_config(amount=1000, form_id=\"f1\", button_id=\"b1\", description=\"A\")\nsub = build_subscription_widget_config(amount=2000, period=\"monthly\", form_id=\"f2\", button_id=\"b2\", description=\"B\")\nrec = build_recurring_widget_config(amount=3000, form_id=\"f3\", button_id=\"b3\", description=\"C\")\n\nbundle = build_widget_bundle_envelope(widgets={\n  \"oneTimeA\": one[\"widgets\"][\"oneTime\"],\n  \"subMonthly\": sub[\"widgets\"][\"subscription\"],\n  \"rec\": rec[\"widgets\"][\"recurring\"],\n})\n</code></pre>"}]}